/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

/**
 * The symbol of the faction.
 */
export enum FactionSymbolJsonFactionSymbolJson {
    Cosmic = "COSMIC",
    Void = "VOID",
    Galactic = "GALACTIC",
    Quantum = "QUANTUM",
    Dominion = "DOMINION",
    Astro = "ASTRO",
    Corsairs = "CORSAIRS",
    Obsidian = "OBSIDIAN",
    Aegis = "AEGIS",
    United = "UNITED",
    Solitary = "SOLITARY",
    Cobalt = "COBALT",
    Omega = "OMEGA",
    Echo = "ECHO",
    Lords = "LORDS",
    Cult = "CULT",
    Ancients = "ANCIENTS",
    Shadow = "SHADOW",
    Ethereal = "ETHEREAL",
}

/**
 * The unique identifier of the trait.
 */
export enum FactionTraitSymbolJson {
    Bureaucratic = "BUREAUCRATIC",
    Secretive = "SECRETIVE",
    Capitalistic = "CAPITALISTIC",
    Industrious = "INDUSTRIOUS",
    Peaceful = "PEACEFUL",
    Distrustful = "DISTRUSTFUL",
    Welcoming = "WELCOMING",
    Smugglers = "SMUGGLERS",
    Scavengers = "SCAVENGERS",
    Rebellious = "REBELLIOUS",
    Exiles = "EXILES",
    Pirates = "PIRATES",
    Raiders = "RAIDERS",
    Clan = "CLAN",
    Guild = "GUILD",
    Dominion = "DOMINION",
    Fringe = "FRINGE",
    Forsaken = "FORSAKEN",
    Isolated = "ISOLATED",
    Localized = "LOCALIZED",
    Established = "ESTABLISHED",
    Notable = "NOTABLE",
    Dominant = "DOMINANT",
    Inescapable = "INESCAPABLE",
    Innovative = "INNOVATIVE",
    Bold = "BOLD",
    Visionary = "VISIONARY",
    Curious = "CURIOUS",
    Daring = "DARING",
    Exploratory = "EXPLORATORY",
    Resourceful = "RESOURCEFUL",
    Flexible = "FLEXIBLE",
    Cooperative = "COOPERATIVE",
    United = "UNITED",
    Strategic = "STRATEGIC",
    Intelligent = "INTELLIGENT",
    ResearchFocused = "RESEARCH_FOCUSED",
    Collaborative = "COLLABORATIVE",
    Progressive = "PROGRESSIVE",
    Militaristic = "MILITARISTIC",
    TechnologicallyAdvanced = "TECHNOLOGICALLY_ADVANCED",
    Aggressive = "AGGRESSIVE",
    Imperialistic = "IMPERIALISTIC",
    TreasureHunters = "TREASURE_HUNTERS",
    Dexterous = "DEXTEROUS",
    Unpredictable = "UNPREDICTABLE",
    Brutal = "BRUTAL",
    Fleeting = "FLEETING",
    Adaptable = "ADAPTABLE",
    SelfSufficient = "SELF_SUFFICIENT",
    Defensive = "DEFENSIVE",
    Proud = "PROUD",
    Diverse = "DIVERSE",
    Independent = "INDEPENDENT",
    SelfInterested = "SELF_INTERESTED",
    Fragmented = "FRAGMENTED",
    Commercial = "COMMERCIAL",
    FreeMarkets = "FREE_MARKETS",
    Entrepreneurial = "ENTREPRENEURIAL",
}

export type FactionTraitJson = {
    /**
     * The unique identifier of the trait.
     */
    symbol: FactionTraitSymbolJson;
    /**
     * The name of the trait.
     */
    name: string;
    /**
     * A description of the trait.
     */
    description: string;
};

/**
 * Faction details.
 */
export type FactionJson = {
    /**
     * The symbol of the faction.
     */
    symbol: FactionSymbolJsonFactionSymbolJson;
    /**
     * Name of the faction.
     */
    name: string;
    /**
     * Description of the faction.
     */
    description: string;
    /**
     * The waypoint in which the faction's HQ is located in.
     */
    headquarters: string;
    /**
     * List of traits that define this faction.
     */
    traits: Array<FactionTraitJson>;
    /**
     * Whether or not the faction is currently recruiting new agents.
     */
    isRecruiting: boolean;
};

/**
 * The registered role of the ship
 */
export enum ShipRoleJson {
    Fabricator = "FABRICATOR",
    Harvester = "HARVESTER",
    Hauler = "HAULER",
    Interceptor = "INTERCEPTOR",
    Excavator = "EXCAVATOR",
    Transport = "TRANSPORT",
    Repair = "REPAIR",
    Surveyor = "SURVEYOR",
    Command = "COMMAND",
    Carrier = "CARRIER",
    Patrol = "PATROL",
    Satellite = "SATELLITE",
    Explorer = "EXPLORER",
    Refinery = "REFINERY",
}

/**
 * The public registration information of the ship
 */
export type ShipRegistrationJson = {
    /**
     * The agent's registered name of the ship
     */
    name: string;
    /**
     * The symbol of the faction the ship is registered with
     */
    factionSymbol: string;
    /**
     * The registered role of the ship
     */
    role: ShipRoleJson;
};

/**
 * The type of waypoint.
 */
export enum WaypointTypeJsonWaypointTypeJson {
    Planet = "PLANET",
    GasGiant = "GAS_GIANT",
    Moon = "MOON",
    OrbitalStation = "ORBITAL_STATION",
    JumpGate = "JUMP_GATE",
    AsteroidField = "ASTEROID_FIELD",
    Asteroid = "ASTEROID",
    EngineeredAsteroid = "ENGINEERED_ASTEROID",
    AsteroidBase = "ASTEROID_BASE",
    Nebula = "NEBULA",
    DebrisField = "DEBRIS_FIELD",
    GravityWell = "GRAVITY_WELL",
    ArtificialGravityWell = "ARTIFICIAL_GRAVITY_WELL",
    FuelStation = "FUEL_STATION",
}

/**
 * The destination or departure of a ships nav route.
 */
export type ShipNavRouteWaypointJson = {
    /**
     * The symbol of the waypoint.
     */
    symbol: string;
    /**
     * The type of waypoint.
     */
    type: WaypointTypeJsonWaypointTypeJson;
    /**
     * The symbol of the system.
     */
    systemSymbol: string;
    /**
     * Position in the universe in the x axis.
     */
    x: number;
    /**
     * Position in the universe in the y axis.
     */
    y: number;
};

/**
 * The routing information for the ship's most recent transit or current location.
 */
export type ShipNavRouteJson = {
    /**
     * The destination or departure of a ships nav route.
     */
    destination: ShipNavRouteWaypointJson;
    /**
     * The destination or departure of a ships nav route.
     */
    origin: ShipNavRouteWaypointJson;
    /**
     * The date time of the ship's departure.
     */
    departureTime: Date;
    /**
     * The date time of the ship's arrival. If the ship is in-transit, this is the expected time of arrival.
     */
    arrival: Date;
};

/**
 * The current status of the ship
 */
export enum ShipNavStatusJson {
    InTransit = "IN_TRANSIT",
    InOrbit = "IN_ORBIT",
    Docked = "DOCKED",
}

/**
 * The ship's set speed when traveling between waypoints or systems.
 */
export enum ShipNavFlightModeJsonShipNavFlightModeJson {
    Drift = "DRIFT",
    Stealth = "STEALTH",
    Cruise = "CRUISE",
    Burn = "BURN",
}

/**
 * The navigation information of the ship.
 */
export type ShipNavJsonShipNavJson = {
    /**
     * The symbol of the system.
     */
    systemSymbol: string;
    /**
     * The symbol of the waypoint.
     */
    waypointSymbol: string;
    /**
     * The routing information for the ship's most recent transit or current location.
     */
    route: ShipNavRouteJson;
    /**
     * The current status of the ship
     */
    status: ShipNavStatusJson;
    /**
     * The ship's set speed when traveling between waypoints or systems.
     */
    flightMode?: ShipNavFlightModeJsonShipNavFlightModeJson | undefined;
};

/**
 * The rotation of crew shifts. A stricter shift improves the ship's performance. A more relaxed shift improves the crew's morale.
 */
export enum Rotation {
    Strict = "STRICT",
    Relaxed = "RELAXED",
}

/**
 * The ship's crew service and maintain the ship's systems and equipment.
 */
export type ShipCrewJson = {
    /**
     * The current number of crew members on the ship.
     */
    current: number;
    /**
     * The minimum number of crew members required to maintain the ship.
     */
    required: number;
    /**
     * The maximum number of crew members the ship can support.
     */
    capacity: number;
    /**
     * The rotation of crew shifts. A stricter shift improves the ship's performance. A more relaxed shift improves the crew's morale.
     */
    rotation?: Rotation | undefined;
    /**
     * A rough measure of the crew's morale. A higher morale means the crew is happier and more productive. A lower morale means the ship is more prone to accidents.
     */
    morale: number;
    /**
     * The amount of credits per crew member paid per hour. Wages are paid when a ship docks at a civilized waypoint.
     */
    wages: number;
};

/**
 * Symbol of the frame.
 */
export enum Symbol {
    FrameProbe = "FRAME_PROBE",
    FrameDrone = "FRAME_DRONE",
    FrameInterceptor = "FRAME_INTERCEPTOR",
    FrameRacer = "FRAME_RACER",
    FrameFighter = "FRAME_FIGHTER",
    FrameFrigate = "FRAME_FRIGATE",
    FrameShuttle = "FRAME_SHUTTLE",
    FrameExplorer = "FRAME_EXPLORER",
    FrameMiner = "FRAME_MINER",
    FrameLightFreighter = "FRAME_LIGHT_FREIGHTER",
    FrameHeavyFreighter = "FRAME_HEAVY_FREIGHTER",
    FrameTransport = "FRAME_TRANSPORT",
    FrameDestroyer = "FRAME_DESTROYER",
    FrameCruiser = "FRAME_CRUISER",
    FrameCarrier = "FRAME_CARRIER",
}

/**
 * The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
 */
export type ShipFrameJson = {
    /**
     * Symbol of the frame.
     */
    symbol: Symbol;
    /**
     * Name of the frame.
     */
    name: string;
    /**
     * Description of the frame.
     */
    description: string;
    /**
     * The repairable condition of a component. A value of 0 indicates the component needs significant repairs, while a value of 1 indicates the component is in near perfect condition. As the condition of a component is repaired, the overall integrity of the component decreases.
     */
    condition: number;
    /**
     * The overall integrity of the component, which determines the performance of the component. A value of 0 indicates that the component is almost completely degraded, while a value of 1 indicates that the component is in near perfect condition. The integrity of the component is non-repairable, and represents permanent wear over time.
     */
    integrity: number;
    /**
     * The amount of slots that can be dedicated to modules installed in the ship. Each installed module take up a number of slots, and once there are no more slots, no new modules can be installed.
     */
    moduleSlots: number;
    /**
     * The amount of slots that can be dedicated to mounts installed in the ship. Each installed mount takes up a number of points, and once there are no more points remaining, no new mounts can be installed.
     */
    mountingPoints: number;
    /**
     * The maximum amount of fuel that can be stored in this ship. When refueling, the ship will be refueled to this amount.
     */
    fuelCapacity: number;
    /**
     * The requirements for installation on a ship
     */
    requirements: ShipRequirementsJson;
};

/**
 * Symbol of the reactor.
 */
export enum ShipReactorJsonSymbol {
    ReactorSolarI = "REACTOR_SOLAR_I",
    ReactorFusionI = "REACTOR_FUSION_I",
    ReactorFissionI = "REACTOR_FISSION_I",
    ReactorChemicalI = "REACTOR_CHEMICAL_I",
    ReactorAntimatterI = "REACTOR_ANTIMATTER_I",
}

/**
 * The reactor of the ship. The reactor is responsible for powering the ship's systems and weapons.
 */
export type ShipReactorJson = {
    /**
     * Symbol of the reactor.
     */
    symbol: ShipReactorJsonSymbol;
    /**
     * Name of the reactor.
     */
    name: string;
    /**
     * Description of the reactor.
     */
    description: string;
    /**
     * The repairable condition of a component. A value of 0 indicates the component needs significant repairs, while a value of 1 indicates the component is in near perfect condition. As the condition of a component is repaired, the overall integrity of the component decreases.
     */
    condition: number;
    /**
     * The overall integrity of the component, which determines the performance of the component. A value of 0 indicates that the component is almost completely degraded, while a value of 1 indicates that the component is in near perfect condition. The integrity of the component is non-repairable, and represents permanent wear over time.
     */
    integrity: number;
    /**
     * The amount of power provided by this reactor. The more power a reactor provides to the ship, the lower the cooldown it gets when using a module or mount that taxes the ship's power.
     */
    powerOutput: number;
    /**
     * The requirements for installation on a ship
     */
    requirements: ShipRequirementsJson;
};

/**
 * The symbol of the engine.
 */
export enum ShipEngineJsonSymbol {
    EngineImpulseDriveI = "ENGINE_IMPULSE_DRIVE_I",
    EngineIonDriveI = "ENGINE_ION_DRIVE_I",
    EngineIonDriveIi = "ENGINE_ION_DRIVE_II",
    EngineHyperDriveI = "ENGINE_HYPER_DRIVE_I",
}

/**
 * The engine determines how quickly a ship travels between waypoints.
 */
export type ShipEngineJson = {
    /**
     * The symbol of the engine.
     */
    symbol: ShipEngineJsonSymbol;
    /**
     * The name of the engine.
     */
    name: string;
    /**
     * The description of the engine.
     */
    description: string;
    /**
     * The repairable condition of a component. A value of 0 indicates the component needs significant repairs, while a value of 1 indicates the component is in near perfect condition. As the condition of a component is repaired, the overall integrity of the component decreases.
     */
    condition: number;
    /**
     * The overall integrity of the component, which determines the performance of the component. A value of 0 indicates that the component is almost completely degraded, while a value of 1 indicates that the component is in near perfect condition. The integrity of the component is non-repairable, and represents permanent wear over time.
     */
    integrity: number;
    /**
     * The speed stat of this engine. The higher the speed, the faster a ship can travel from one point to another. Reduces the time of arrival when navigating the ship.
     */
    speed: number;
    /**
     * The requirements for installation on a ship
     */
    requirements: ShipRequirementsJson;
};

/**
 * A cooldown is a period of time in which a ship cannot perform certain actions.
 */
export type CooldownJsonCooldownJson = {
    /**
     * The symbol of the ship that is on cooldown
     */
    shipSymbol: string;
    /**
     * The total duration of the cooldown in seconds
     */
    totalSeconds: number;
    /**
     * The remaining duration of the cooldown in seconds
     */
    remainingSeconds: number;
    /**
     * The date and time when the cooldown expires in ISO 8601 format
     */
    expiration?: Date | undefined;
};

/**
 * The symbol of the module.
 */
export enum ShipModuleJsonSymbol {
    ModuleMineralProcessorI = "MODULE_MINERAL_PROCESSOR_I",
    ModuleGasProcessorI = "MODULE_GAS_PROCESSOR_I",
    ModuleCargoHoldI = "MODULE_CARGO_HOLD_I",
    ModuleCargoHoldIi = "MODULE_CARGO_HOLD_II",
    ModuleCargoHoldIii = "MODULE_CARGO_HOLD_III",
    ModuleCrewQuartersI = "MODULE_CREW_QUARTERS_I",
    ModuleEnvoyQuartersI = "MODULE_ENVOY_QUARTERS_I",
    ModulePassengerCabinI = "MODULE_PASSENGER_CABIN_I",
    ModuleMicroRefineryI = "MODULE_MICRO_REFINERY_I",
    ModuleOreRefineryI = "MODULE_ORE_REFINERY_I",
    ModuleFuelRefineryI = "MODULE_FUEL_REFINERY_I",
    ModuleScienceLabI = "MODULE_SCIENCE_LAB_I",
    ModuleJumpDriveI = "MODULE_JUMP_DRIVE_I",
    ModuleJumpDriveIi = "MODULE_JUMP_DRIVE_II",
    ModuleJumpDriveIii = "MODULE_JUMP_DRIVE_III",
    ModuleWarpDriveI = "MODULE_WARP_DRIVE_I",
    ModuleWarpDriveIi = "MODULE_WARP_DRIVE_II",
    ModuleWarpDriveIii = "MODULE_WARP_DRIVE_III",
    ModuleShieldGeneratorI = "MODULE_SHIELD_GENERATOR_I",
    ModuleShieldGeneratorIi = "MODULE_SHIELD_GENERATOR_II",
}

/**
 * A module can be installed in a ship and provides a set of capabilities such as storage space or quarters for crew. Module installations are permanent.
 */
export type ShipModuleJson = {
    /**
     * The symbol of the module.
     */
    symbol: ShipModuleJsonSymbol;
    /**
     * Modules that provide capacity, such as cargo hold or crew quarters will show this value to denote how much of a bonus the module grants.
     */
    capacity?: number | undefined;
    /**
     * Modules that have a range will such as a sensor array show this value to denote how far can the module reach with its capabilities.
     */
    range?: number | undefined;
    /**
     * Name of this module.
     */
    name: string;
    /**
     * Description of this module.
     */
    description: string;
    /**
     * The requirements for installation on a ship
     */
    requirements: ShipRequirementsJson;
};

/**
 * Symbo of this mount.
 */
export enum ShipMountJsonSymbol {
    MountGasSiphonI = "MOUNT_GAS_SIPHON_I",
    MountGasSiphonIi = "MOUNT_GAS_SIPHON_II",
    MountGasSiphonIii = "MOUNT_GAS_SIPHON_III",
    MountSurveyorI = "MOUNT_SURVEYOR_I",
    MountSurveyorIi = "MOUNT_SURVEYOR_II",
    MountSurveyorIii = "MOUNT_SURVEYOR_III",
    MountSensorArrayI = "MOUNT_SENSOR_ARRAY_I",
    MountSensorArrayIi = "MOUNT_SENSOR_ARRAY_II",
    MountSensorArrayIii = "MOUNT_SENSOR_ARRAY_III",
    MountMiningLaserI = "MOUNT_MINING_LASER_I",
    MountMiningLaserIi = "MOUNT_MINING_LASER_II",
    MountMiningLaserIii = "MOUNT_MINING_LASER_III",
    MountLaserCannonI = "MOUNT_LASER_CANNON_I",
    MountMissileLauncherI = "MOUNT_MISSILE_LAUNCHER_I",
    MountTurretI = "MOUNT_TURRET_I",
}

export enum Deposits {
    QuartzSand = "QUARTZ_SAND",
    SiliconCrystals = "SILICON_CRYSTALS",
    PreciousStones = "PRECIOUS_STONES",
    IceWater = "ICE_WATER",
    AmmoniaIce = "AMMONIA_ICE",
    IronOre = "IRON_ORE",
    CopperOre = "COPPER_ORE",
    SilverOre = "SILVER_ORE",
    AluminumOre = "ALUMINUM_ORE",
    GoldOre = "GOLD_ORE",
    PlatinumOre = "PLATINUM_ORE",
    Diamonds = "DIAMONDS",
    UraniteOre = "URANITE_ORE",
    MeritiumOre = "MERITIUM_ORE",
}

/**
 * The requirements for installation on a ship
 */
export type ShipRequirementsJson = {
    /**
     * The amount of power required from the reactor.
     */
    power?: number | undefined;
    /**
     * The number of crew required for operation.
     */
    crew?: number | undefined;
    /**
     * The number of module slots required for installation.
     */
    slots?: number | undefined;
};

/**
 * A mount is installed on the exterier of a ship.
 */
export type ShipMountJsonShipMountJson = {
    /**
     * Symbo of this mount.
     */
    symbol: ShipMountJsonSymbol;
    /**
     * Name of this mount.
     */
    name: string;
    /**
     * Description of this mount.
     */
    description?: string | undefined;
    /**
     * Mounts that have this value, such as mining lasers, denote how powerful this mount's capabilities are.
     */
    strength?: number | undefined;
    /**
     * Mounts that have this value denote what goods can be produced from using the mount.
     */
    deposits?: Array<Deposits> | undefined;
    /**
     * The requirements for installation on a ship
     */
    requirements: ShipRequirementsJson;
};

/**
 * The good's symbol.
 */
export enum TradeSymbolJsonTradeSymbolJson {
    PreciousStones = "PRECIOUS_STONES",
    QuartzSand = "QUARTZ_SAND",
    SiliconCrystals = "SILICON_CRYSTALS",
    AmmoniaIce = "AMMONIA_ICE",
    LiquidHydrogen = "LIQUID_HYDROGEN",
    LiquidNitrogen = "LIQUID_NITROGEN",
    IceWater = "ICE_WATER",
    ExoticMatter = "EXOTIC_MATTER",
    AdvancedCircuitry = "ADVANCED_CIRCUITRY",
    GravitonEmitters = "GRAVITON_EMITTERS",
    Iron = "IRON",
    IronOre = "IRON_ORE",
    Copper = "COPPER",
    CopperOre = "COPPER_ORE",
    Aluminum = "ALUMINUM",
    AluminumOre = "ALUMINUM_ORE",
    Silver = "SILVER",
    SilverOre = "SILVER_ORE",
    Gold = "GOLD",
    GoldOre = "GOLD_ORE",
    Platinum = "PLATINUM",
    PlatinumOre = "PLATINUM_ORE",
    Diamonds = "DIAMONDS",
    Uranite = "URANITE",
    UraniteOre = "URANITE_ORE",
    Meritium = "MERITIUM",
    MeritiumOre = "MERITIUM_ORE",
    Hydrocarbon = "HYDROCARBON",
    Antimatter = "ANTIMATTER",
    FabMats = "FAB_MATS",
    Fertilizers = "FERTILIZERS",
    Fabrics = "FABRICS",
    Food = "FOOD",
    Jewelry = "JEWELRY",
    Machinery = "MACHINERY",
    Firearms = "FIREARMS",
    AssaultRifles = "ASSAULT_RIFLES",
    MilitaryEquipment = "MILITARY_EQUIPMENT",
    Explosives = "EXPLOSIVES",
    LabInstruments = "LAB_INSTRUMENTS",
    Ammunition = "AMMUNITION",
    Electronics = "ELECTRONICS",
    ShipPlating = "SHIP_PLATING",
    ShipParts = "SHIP_PARTS",
    Equipment = "EQUIPMENT",
    Fuel = "FUEL",
    Medicine = "MEDICINE",
    Drugs = "DRUGS",
    Clothing = "CLOTHING",
    Microprocessors = "MICROPROCESSORS",
    Plastics = "PLASTICS",
    Polynucleotides = "POLYNUCLEOTIDES",
    Biocomposites = "BIOCOMPOSITES",
    QuantumStabilizers = "QUANTUM_STABILIZERS",
    Nanobots = "NANOBOTS",
    AiMainframes = "AI_MAINFRAMES",
    QuantumDrives = "QUANTUM_DRIVES",
    RoboticDrones = "ROBOTIC_DRONES",
    CyberImplants = "CYBER_IMPLANTS",
    GeneTherapeutics = "GENE_THERAPEUTICS",
    NeuralChips = "NEURAL_CHIPS",
    MoodRegulators = "MOOD_REGULATORS",
    ViralAgents = "VIRAL_AGENTS",
    MicroFusionGenerators = "MICRO_FUSION_GENERATORS",
    Supergrains = "SUPERGRAINS",
    LaserRifles = "LASER_RIFLES",
    Holographics = "HOLOGRAPHICS",
    ShipSalvage = "SHIP_SALVAGE",
    RelicTech = "RELIC_TECH",
    NovelLifeforms = "NOVEL_LIFEFORMS",
    BotanicalSpecimens = "BOTANICAL_SPECIMENS",
    CulturalArtifacts = "CULTURAL_ARTIFACTS",
    FrameProbe = "FRAME_PROBE",
    FrameDrone = "FRAME_DRONE",
    FrameInterceptor = "FRAME_INTERCEPTOR",
    FrameRacer = "FRAME_RACER",
    FrameFighter = "FRAME_FIGHTER",
    FrameFrigate = "FRAME_FRIGATE",
    FrameShuttle = "FRAME_SHUTTLE",
    FrameExplorer = "FRAME_EXPLORER",
    FrameMiner = "FRAME_MINER",
    FrameLightFreighter = "FRAME_LIGHT_FREIGHTER",
    FrameHeavyFreighter = "FRAME_HEAVY_FREIGHTER",
    FrameTransport = "FRAME_TRANSPORT",
    FrameDestroyer = "FRAME_DESTROYER",
    FrameCruiser = "FRAME_CRUISER",
    FrameCarrier = "FRAME_CARRIER",
    ReactorSolarI = "REACTOR_SOLAR_I",
    ReactorFusionI = "REACTOR_FUSION_I",
    ReactorFissionI = "REACTOR_FISSION_I",
    ReactorChemicalI = "REACTOR_CHEMICAL_I",
    ReactorAntimatterI = "REACTOR_ANTIMATTER_I",
    EngineImpulseDriveI = "ENGINE_IMPULSE_DRIVE_I",
    EngineIonDriveI = "ENGINE_ION_DRIVE_I",
    EngineIonDriveIi = "ENGINE_ION_DRIVE_II",
    EngineHyperDriveI = "ENGINE_HYPER_DRIVE_I",
    ModuleMineralProcessorI = "MODULE_MINERAL_PROCESSOR_I",
    ModuleGasProcessorI = "MODULE_GAS_PROCESSOR_I",
    ModuleCargoHoldI = "MODULE_CARGO_HOLD_I",
    ModuleCargoHoldIi = "MODULE_CARGO_HOLD_II",
    ModuleCargoHoldIii = "MODULE_CARGO_HOLD_III",
    ModuleCrewQuartersI = "MODULE_CREW_QUARTERS_I",
    ModuleEnvoyQuartersI = "MODULE_ENVOY_QUARTERS_I",
    ModulePassengerCabinI = "MODULE_PASSENGER_CABIN_I",
    ModuleMicroRefineryI = "MODULE_MICRO_REFINERY_I",
    ModuleScienceLabI = "MODULE_SCIENCE_LAB_I",
    ModuleJumpDriveI = "MODULE_JUMP_DRIVE_I",
    ModuleJumpDriveIi = "MODULE_JUMP_DRIVE_II",
    ModuleJumpDriveIii = "MODULE_JUMP_DRIVE_III",
    ModuleWarpDriveI = "MODULE_WARP_DRIVE_I",
    ModuleWarpDriveIi = "MODULE_WARP_DRIVE_II",
    ModuleWarpDriveIii = "MODULE_WARP_DRIVE_III",
    ModuleShieldGeneratorI = "MODULE_SHIELD_GENERATOR_I",
    ModuleShieldGeneratorIi = "MODULE_SHIELD_GENERATOR_II",
    ModuleOreRefineryI = "MODULE_ORE_REFINERY_I",
    ModuleFuelRefineryI = "MODULE_FUEL_REFINERY_I",
    MountGasSiphonI = "MOUNT_GAS_SIPHON_I",
    MountGasSiphonIi = "MOUNT_GAS_SIPHON_II",
    MountGasSiphonIii = "MOUNT_GAS_SIPHON_III",
    MountSurveyorI = "MOUNT_SURVEYOR_I",
    MountSurveyorIi = "MOUNT_SURVEYOR_II",
    MountSurveyorIii = "MOUNT_SURVEYOR_III",
    MountSensorArrayI = "MOUNT_SENSOR_ARRAY_I",
    MountSensorArrayIi = "MOUNT_SENSOR_ARRAY_II",
    MountSensorArrayIii = "MOUNT_SENSOR_ARRAY_III",
    MountMiningLaserI = "MOUNT_MINING_LASER_I",
    MountMiningLaserIi = "MOUNT_MINING_LASER_II",
    MountMiningLaserIii = "MOUNT_MINING_LASER_III",
    MountLaserCannonI = "MOUNT_LASER_CANNON_I",
    MountMissileLauncherI = "MOUNT_MISSILE_LAUNCHER_I",
    MountTurretI = "MOUNT_TURRET_I",
    ShipProbe = "SHIP_PROBE",
    ShipMiningDrone = "SHIP_MINING_DRONE",
    ShipSiphonDrone = "SHIP_SIPHON_DRONE",
    ShipInterceptor = "SHIP_INTERCEPTOR",
    ShipLightHauler = "SHIP_LIGHT_HAULER",
    ShipCommandFrigate = "SHIP_COMMAND_FRIGATE",
    ShipExplorer = "SHIP_EXPLORER",
    ShipHeavyFreighter = "SHIP_HEAVY_FREIGHTER",
    ShipLightShuttle = "SHIP_LIGHT_SHUTTLE",
    ShipOreHound = "SHIP_ORE_HOUND",
    ShipRefiningFreighter = "SHIP_REFINING_FREIGHTER",
    ShipSurveyor = "SHIP_SURVEYOR",
}

/**
 * The type of cargo item and the number of units.
 */
export type ShipCargoItemJson = {
    /**
     * The good's symbol.
     */
    symbol: TradeSymbolJsonTradeSymbolJson;
    /**
     * The name of the cargo item type.
     */
    name: string;
    /**
     * The description of the cargo item type.
     */
    description: string;
    /**
     * The number of units of the cargo item.
     */
    units: number;
};

/**
 * Ship cargo details.
 */
export type ShipCargoJsonShipCargoJson = {
    /**
     * The max number of items that can be stored in the cargo hold.
     */
    capacity: number;
    /**
     * The number of items currently stored in the cargo hold.
     */
    units: number;
    /**
     * The items currently in the cargo hold.
     */
    inventory: Array<ShipCargoItemJson>;
};

/**
 * An object that only shows up when an action has consumed fuel in the process. Shows the fuel consumption data.
 */
export type Consumed = {
    /**
     * The amount of fuel consumed by the most recent transit or action.
     */
    amount: number;
    /**
     * The time at which the fuel was consumed.
     */
    timestamp: Date;
};

/**
 * Details of the ship's fuel tanks including how much fuel was consumed during the last transit or action.
 */
export type ShipFuelJsonShipFuelJson = {
    /**
     * The current amount of fuel in the ship's tanks.
     */
    current: number;
    /**
     * The maximum amount of fuel the ship's tanks can hold.
     */
    capacity: number;
    /**
     * An object that only shows up when an action has consumed fuel in the process. Shows the fuel consumption data.
     */
    consumed?: Consumed | undefined;
};

/**
 * Ship details.
 */
export type ShipJson = {
    /**
     * The globally unique identifier of the ship in the following format: `[AGENT_SYMBOL]-[HEX_ID]`
     */
    symbol: string;
    /**
     * The public registration information of the ship
     */
    registration: ShipRegistrationJson;
    /**
     * The navigation information of the ship.
     */
    nav: ShipNavJsonShipNavJson;
    /**
     * The ship's crew service and maintain the ship's systems and equipment.
     */
    crew: ShipCrewJson;
    /**
     * The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
     */
    frame: ShipFrameJson;
    /**
     * The reactor of the ship. The reactor is responsible for powering the ship's systems and weapons.
     */
    reactor: ShipReactorJson;
    /**
     * The engine determines how quickly a ship travels between waypoints.
     */
    engine: ShipEngineJson;
    /**
     * A cooldown is a period of time in which a ship cannot perform certain actions.
     */
    cooldown: CooldownJsonCooldownJson;
    /**
     * Modules installed in this ship.
     */
    modules: Array<ShipModuleJson>;
    /**
     * Mounts installed in this ship.
     */
    mounts: Array<ShipMountJsonShipMountJson>;
    /**
     * Ship cargo details.
     */
    cargo: ShipCargoJsonShipCargoJson;
    /**
     * Details of the ship's fuel tanks including how much fuel was consumed during the last transit or action.
     */
    fuel: ShipFuelJsonShipFuelJson;
};

/**
 * The type of system.
 */
export enum SystemTypeJson {
    NeutronStar = "NEUTRON_STAR",
    RedStar = "RED_STAR",
    OrangeStar = "ORANGE_STAR",
    BlueStar = "BLUE_STAR",
    YoungStar = "YOUNG_STAR",
    WhiteDwarf = "WHITE_DWARF",
    BlackHole = "BLACK_HOLE",
    Hypergiant = "HYPERGIANT",
    Nebula = "NEBULA",
    Unstable = "UNSTABLE",
}

/**
 * An orbital is another waypoint that orbits a parent waypoint.
 */
export type WaypointOrbitalJson = {
    /**
     * The symbol of the orbiting waypoint.
     */
    symbol: string;
};

export type SystemWaypointJson = {
    /**
     * The symbol of the waypoint.
     */
    symbol: string;
    /**
     * The type of waypoint.
     */
    type: WaypointTypeJsonWaypointTypeJson;
    /**
     * Relative position of the waypoint on the system's x axis. This is not an absolute position in the universe.
     */
    x: number;
    /**
     * Relative position of the waypoint on the system's y axis. This is not an absolute position in the universe.
     */
    y: number;
    /**
     * Waypoints that orbit this waypoint.
     */
    orbitals: Array<WaypointOrbitalJson>;
    /**
     * The symbol of the parent waypoint, if this waypoint is in orbit around another waypoint. Otherwise this value is undefined.
     */
    orbits?: string | undefined;
};

export type SystemFactionJson = {
    /**
     * The symbol of the faction.
     */
    symbol: FactionSymbolJsonFactionSymbolJson;
};

export type SystemJson = {
    /**
     * The symbol of the system.
     */
    symbol: string;
    /**
     * The symbol of the sector.
     */
    sectorSymbol: string;
    /**
     * The type of system.
     */
    type: SystemTypeJson;
    /**
     * Relative position of the system in the sector in the x axis.
     */
    x: number;
    /**
     * Relative position of the system in the sector in the y axis.
     */
    y: number;
    /**
     * Waypoints in this system.
     */
    waypoints: Array<SystemWaypointJson>;
    /**
     * Factions that control this system.
     */
    factions: Array<SystemFactionJson>;
};

/**
 * The faction that controls the waypoint.
 */
export type WaypointFactionJson = {
    /**
     * The symbol of the faction.
     */
    symbol: FactionSymbolJsonFactionSymbolJson;
};

/**
 * The unique identifier of the trait.
 */
export enum WaypointTraitSymbolJsonWaypointTraitSymbolJson {
    Uncharted = "UNCHARTED",
    UnderConstruction = "UNDER_CONSTRUCTION",
    Marketplace = "MARKETPLACE",
    Shipyard = "SHIPYARD",
    Outpost = "OUTPOST",
    ScatteredSettlements = "SCATTERED_SETTLEMENTS",
    SprawlingCities = "SPRAWLING_CITIES",
    MegaStructures = "MEGA_STRUCTURES",
    PirateBase = "PIRATE_BASE",
    Overcrowded = "OVERCROWDED",
    HighTech = "HIGH_TECH",
    Corrupt = "CORRUPT",
    Bureaucratic = "BUREAUCRATIC",
    TradingHub = "TRADING_HUB",
    Industrial = "INDUSTRIAL",
    BlackMarket = "BLACK_MARKET",
    ResearchFacility = "RESEARCH_FACILITY",
    MilitaryBase = "MILITARY_BASE",
    SurveillanceOutpost = "SURVEILLANCE_OUTPOST",
    ExplorationOutpost = "EXPLORATION_OUTPOST",
    MineralDeposits = "MINERAL_DEPOSITS",
    CommonMetalDeposits = "COMMON_METAL_DEPOSITS",
    PreciousMetalDeposits = "PRECIOUS_METAL_DEPOSITS",
    RareMetalDeposits = "RARE_METAL_DEPOSITS",
    MethanePools = "METHANE_POOLS",
    IceCrystals = "ICE_CRYSTALS",
    ExplosiveGases = "EXPLOSIVE_GASES",
    StrongMagnetosphere = "STRONG_MAGNETOSPHERE",
    VibrantAuroras = "VIBRANT_AURORAS",
    SaltFlats = "SALT_FLATS",
    Canyons = "CANYONS",
    PerpetualDaylight = "PERPETUAL_DAYLIGHT",
    PerpetualOvercast = "PERPETUAL_OVERCAST",
    DrySeabeds = "DRY_SEABEDS",
    MagmaSeas = "MAGMA_SEAS",
    Supervolcanoes = "SUPERVOLCANOES",
    AshClouds = "ASH_CLOUDS",
    VastRuins = "VAST_RUINS",
    MutatedFlora = "MUTATED_FLORA",
    Terraformed = "TERRAFORMED",
    ExtremeTemperatures = "EXTREME_TEMPERATURES",
    ExtremePressure = "EXTREME_PRESSURE",
    DiverseLife = "DIVERSE_LIFE",
    ScarceLife = "SCARCE_LIFE",
    Fossils = "FOSSILS",
    WeakGravity = "WEAK_GRAVITY",
    StrongGravity = "STRONG_GRAVITY",
    CrushingGravity = "CRUSHING_GRAVITY",
    ToxicAtmosphere = "TOXIC_ATMOSPHERE",
    CorrosiveAtmosphere = "CORROSIVE_ATMOSPHERE",
    BreathableAtmosphere = "BREATHABLE_ATMOSPHERE",
    ThinAtmosphere = "THIN_ATMOSPHERE",
    Jovian = "JOVIAN",
    Rocky = "ROCKY",
    Volcanic = "VOLCANIC",
    Frozen = "FROZEN",
    Swamp = "SWAMP",
    Barren = "BARREN",
    Temperate = "TEMPERATE",
    Jungle = "JUNGLE",
    Ocean = "OCEAN",
    Radioactive = "RADIOACTIVE",
    MicroGravityAnomalies = "MICRO_GRAVITY_ANOMALIES",
    DebrisCluster = "DEBRIS_CLUSTER",
    DeepCraters = "DEEP_CRATERS",
    ShallowCraters = "SHALLOW_CRATERS",
    UnstableComposition = "UNSTABLE_COMPOSITION",
    HollowedInterior = "HOLLOWED_INTERIOR",
    Stripped = "STRIPPED",
}

export type WaypointTraitJson = {
    /**
     * The unique identifier of the trait.
     */
    symbol: WaypointTraitSymbolJsonWaypointTraitSymbolJson;
    /**
     * The name of the trait.
     */
    name: string;
    /**
     * A description of the trait.
     */
    description: string;
};

/**
 * The unique identifier of the modifier.
 */
export enum WaypointModifierSymbolJson {
    Stripped = "STRIPPED",
    Unstable = "UNSTABLE",
    RadiationLeak = "RADIATION_LEAK",
    CriticalLimit = "CRITICAL_LIMIT",
    CivilUnrest = "CIVIL_UNREST",
}

export type WaypointModifierJson = {
    /**
     * The unique identifier of the modifier.
     */
    symbol: WaypointModifierSymbolJson;
    /**
     * The name of the trait.
     */
    name: string;
    /**
     * A description of the trait.
     */
    description: string;
};

/**
 * The chart of a system or waypoint, which makes the location visible to other agents.
 */
export type ChartJsonChartJson = {
    /**
     * The symbol of the waypoint.
     */
    waypointSymbol?: string | undefined;
    /**
     * The agent that submitted the chart for this waypoint.
     */
    submittedBy?: string | undefined;
    /**
     * The time the chart for this waypoint was submitted.
     */
    submittedOn?: Date | undefined;
};

/**
 * A waypoint is a location that ships can travel to such as a Planet, Moon or Space Station.
 */
export type WaypointJson = {
    /**
     * The symbol of the waypoint.
     */
    symbol: string;
    /**
     * The type of waypoint.
     */
    type: WaypointTypeJsonWaypointTypeJson;
    /**
     * The symbol of the system.
     */
    systemSymbol: string;
    /**
     * Relative position of the waypoint on the system's x axis. This is not an absolute position in the universe.
     */
    x: number;
    /**
     * Relative position of the waypoint on the system's y axis. This is not an absolute position in the universe.
     */
    y: number;
    /**
     * Waypoints that orbit this waypoint.
     */
    orbitals: Array<WaypointOrbitalJson>;
    /**
     * The symbol of the parent waypoint, if this waypoint is in orbit around another waypoint. Otherwise this value is undefined.
     */
    orbits?: string | undefined;
    /**
     * The faction that controls the waypoint.
     */
    faction?: WaypointFactionJson | undefined;
    /**
     * The traits of the waypoint.
     */
    traits: Array<WaypointTraitJson>;
    /**
     * The modifiers of the waypoint.
     */
    modifiers?: Array<WaypointModifierJson> | undefined;
    /**
     * The chart of a system or waypoint, which makes the location visible to other agents.
     */
    chart?: ChartJsonChartJson | undefined;
    /**
     * True if the waypoint is under construction.
     */
    isUnderConstruction: boolean;
};

/**
 * A good that can be traded for other goods or currency.
 */
export type TradeGoodJson = {
    /**
     * The good's symbol.
     */
    symbol: TradeSymbolJsonTradeSymbolJson;
    /**
     * The name of the good.
     */
    name: string;
    /**
     * The description of the good.
     */
    description: string;
};

/**
 * The type of transaction.
 */
export enum MarketTransactionJsonType {
    Purchase = "PURCHASE",
    Sell = "SELL",
}

/**
 * Result of a transaction with a market.
 */
export type MarketTransactionJsonMarketTransactionJson = {
    /**
     * The symbol of the waypoint.
     */
    waypointSymbol: string;
    /**
     * The symbol of the ship that made the transaction.
     */
    shipSymbol: string;
    /**
     * The symbol of the trade good.
     */
    tradeSymbol: string;
    /**
     * The type of transaction.
     */
    type: MarketTransactionJsonType;
    /**
     * The number of units of the transaction.
     */
    units: number;
    /**
     * The price per unit of the transaction.
     */
    pricePerUnit: number;
    /**
     * The total price of the transaction.
     */
    totalPrice: number;
    /**
     * The timestamp of the transaction.
     */
    timestamp: Date;
};

/**
 * The type of trade good (export, import, or exchange).
 */
export enum MarketTradeGoodJsonType {
    Export = "EXPORT",
    Import = "IMPORT",
    Exchange = "EXCHANGE",
}

/**
 * The supply level of a trade good.
 */
export enum SupplyLevelJson {
    Scarce = "SCARCE",
    Limited = "LIMITED",
    Moderate = "MODERATE",
    High = "HIGH",
    Abundant = "ABUNDANT",
}

/**
 * The activity level of a trade good. If the good is an import, this represents how strong consumption is. If the good is an export, this represents how strong the production is for the good. When activity is strong, consumption or production is near maximum capacity. When activity is weak, consumption or production is near minimum capacity.
 */
export enum ActivityLevelJson {
    Weak = "WEAK",
    Growing = "GROWING",
    Strong = "STRONG",
    Restricted = "RESTRICTED",
}

export type MarketTradeGoodJson = {
    /**
     * The good's symbol.
     */
    symbol: TradeSymbolJsonTradeSymbolJson;
    /**
     * The type of trade good (export, import, or exchange).
     */
    type: MarketTradeGoodJsonType;
    /**
     * This is the maximum number of units that can be purchased or sold at this market in a single trade for this good. Trade volume also gives an indication of price volatility. A market with a low trade volume will have large price swings, while high trade volume will be more resilient to price changes.
     */
    tradeVolume: number;
    /**
     * The supply level of a trade good.
     */
    supply: SupplyLevelJson;
    /**
     * The activity level of a trade good. If the good is an import, this represents how strong consumption is. If the good is an export, this represents how strong the production is for the good. When activity is strong, consumption or production is near maximum capacity. When activity is weak, consumption or production is near minimum capacity.
     */
    activity?: ActivityLevelJson | undefined;
    /**
     * The price at which this good can be purchased from the market.
     */
    purchasePrice: number;
    /**
     * The price at which this good can be sold to the market.
     */
    sellPrice: number;
};

export type MarketJson = {
    /**
     * The symbol of the market. The symbol is the same as the waypoint where the market is located.
     */
    symbol: string;
    /**
     * The list of goods that are exported from this market.
     */
    exports: Array<TradeGoodJson>;
    /**
     * The list of goods that are sought as imports in this market.
     */
    imports: Array<TradeGoodJson>;
    /**
     * The list of goods that are bought and sold between agents at this market.
     */
    exchange: Array<TradeGoodJson>;
    /**
     * The list of recent transactions at this market. Visible only when a ship is present at the market.
     */
    transactions?: Array<MarketTransactionJsonMarketTransactionJson> | undefined;
    /**
     * The list of goods that are traded at this market. Visible only when a ship is present at the market.
     */
    tradeGoods?: Array<MarketTradeGoodJson> | undefined;
};

export type ShipTypes = {
    /**
     * Type of ship
     */
    type: ShipTypeJsonShipTypeJson;
};

/**
 * Results of a transaction with a shipyard.
 */
export type ShipyardTransactionJsonShipyardTransactionJson = {
    /**
     * The symbol of the waypoint.
     */
    waypointSymbol: string;
    /**
     * The symbol of the ship that was the subject of the transaction.
     *
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    shipSymbol: string;
    /**
     * The symbol of the ship that was the subject of the transaction.
     */
    shipType: string;
    /**
     * The price of the transaction.
     */
    price: number;
    /**
     * The symbol of the agent that made the transaction.
     */
    agentSymbol: string;
    /**
     * The timestamp of the transaction.
     */
    timestamp: Date;
};

/**
 * Type of ship
 */
export enum ShipTypeJsonShipTypeJson {
    ShipProbe = "SHIP_PROBE",
    ShipMiningDrone = "SHIP_MINING_DRONE",
    ShipSiphonDrone = "SHIP_SIPHON_DRONE",
    ShipInterceptor = "SHIP_INTERCEPTOR",
    ShipLightHauler = "SHIP_LIGHT_HAULER",
    ShipCommandFrigate = "SHIP_COMMAND_FRIGATE",
    ShipExplorer = "SHIP_EXPLORER",
    ShipHeavyFreighter = "SHIP_HEAVY_FREIGHTER",
    ShipLightShuttle = "SHIP_LIGHT_SHUTTLE",
    ShipOreHound = "SHIP_ORE_HOUND",
    ShipRefiningFreighter = "SHIP_REFINING_FREIGHTER",
    ShipSurveyor = "SHIP_SURVEYOR",
}

export type Crew = {
    required: number;
    capacity: number;
};

export type ShipyardShipJson = {
    /**
     * Type of ship
     */
    type: ShipTypeJsonShipTypeJson;
    name: string;
    description: string;
    /**
     * The supply level of a trade good.
     */
    supply: SupplyLevelJson;
    /**
     * The activity level of a trade good. If the good is an import, this represents how strong consumption is. If the good is an export, this represents how strong the production is for the good. When activity is strong, consumption or production is near maximum capacity. When activity is weak, consumption or production is near minimum capacity.
     */
    activity?: ActivityLevelJson | undefined;
    purchasePrice: number;
    /**
     * The frame of the ship. The frame determines the number of modules and mounting points of the ship, as well as base fuel capacity. As the condition of the frame takes more wear, the ship will become more sluggish and less maneuverable.
     */
    frame: ShipFrameJson;
    /**
     * The reactor of the ship. The reactor is responsible for powering the ship's systems and weapons.
     */
    reactor: ShipReactorJson;
    /**
     * The engine determines how quickly a ship travels between waypoints.
     */
    engine: ShipEngineJson;
    modules: Array<ShipModuleJson>;
    mounts: Array<ShipMountJsonShipMountJson>;
    crew: Crew;
};

export type ShipyardJson = {
    /**
     * The symbol of the shipyard. The symbol is the same as the waypoint where the shipyard is located.
     */
    symbol: string;
    /**
     * The list of ship types available for purchase at this shipyard.
     */
    shipTypes: Array<ShipTypes>;
    /**
     * The list of recent transactions at this shipyard.
     */
    transactions?: Array<ShipyardTransactionJsonShipyardTransactionJson> | undefined;
    /**
     * The ships that are currently available for purchase at the shipyard.
     */
    ships?: Array<ShipyardShipJson> | undefined;
    /**
     * The fee to modify a ship at this shipyard. This includes installing or removing modules and mounts on a ship. In the case of mounts, the fee is a flat rate per mount. In the case of modules, the fee is per slot the module occupies.
     */
    modificationsFee: number;
};

/**
 * The details of the required construction materials for a given waypoint under construction.
 */
export type ConstructionMaterialJson = {
    /**
     * The good's symbol.
     */
    tradeSymbol: TradeSymbolJsonTradeSymbolJson;
    /**
     * The number of units required.
     */
    required: number;
    /**
     * The number of units fulfilled toward the required amount.
     */
    fulfilled: number;
};

/**
 * The construction details of a waypoint.
 */
export type ConstructionJson = {
    /**
     * The symbol of the waypoint.
     */
    symbol: string;
    /**
     * The materials required to construct the waypoint.
     */
    materials: Array<ConstructionMaterialJson>;
    /**
     * Whether the waypoint has been constructed.
     */
    isComplete: boolean;
};

/**
 * Ship cargo details.
 */
export type ShipCargoJson = {
    /**
     * The max number of items that can be stored in the cargo hold.
     */
    capacity: number;
    /**
     * The number of items currently stored in the cargo hold.
     */
    units: number;
    /**
     * The items currently in the cargo hold.
     */
    inventory: Array<ShipCargoItemJson>;
};

/**
 * The navigation information of the ship.
 */
export type ShipNavJson = {
    /**
     * The symbol of the system.
     */
    systemSymbol: string;
    /**
     * The symbol of the waypoint.
     */
    waypointSymbol: string;
    /**
     * The routing information for the ship's most recent transit or current location.
     */
    route: ShipNavRouteJson;
    /**
     * The current status of the ship
     */
    status: ShipNavStatusJson;
    /**
     * The ship's set speed when traveling between waypoints or systems.
     */
    flightMode?: ShipNavFlightModeJsonShipNavFlightModeJson | undefined;
};

/**
 * A waypoint that was scanned by a ship.
 */
export type ScannedWaypointJson = {
    /**
     * The symbol of the waypoint.
     */
    symbol: string;
    /**
     * The type of waypoint.
     */
    type: WaypointTypeJsonWaypointTypeJson;
    /**
     * The symbol of the system.
     */
    systemSymbol: string;
    /**
     * Position in the universe in the x axis.
     */
    x: number;
    /**
     * Position in the universe in the y axis.
     */
    y: number;
    /**
     * List of waypoints that orbit this waypoint.
     */
    orbitals: Array<WaypointOrbitalJson>;
    /**
     * The faction that controls the waypoint.
     */
    faction?: WaypointFactionJson | undefined;
    /**
     * The traits of the waypoint.
     */
    traits: Array<WaypointTraitJson>;
    /**
     * The chart of a system or waypoint, which makes the location visible to other agents.
     */
    chart?: ChartJsonChartJson | undefined;
};

/** @internal */
export const FactionSymbolJsonFactionSymbolJson$ = z.nativeEnum(FactionSymbolJsonFactionSymbolJson);

/** @internal */
export const FactionTraitSymbolJson$ = z.nativeEnum(FactionTraitSymbolJson);

/** @internal */
export namespace FactionTraitJson$ {
    export type Inbound = {
        symbol: FactionTraitSymbolJson;
        name: string;
        description: string;
    };

    export const inboundSchema: z.ZodType<FactionTraitJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: FactionTraitSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });

    export type Outbound = {
        symbol: FactionTraitSymbolJson;
        name: string;
        description: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, FactionTraitJson> = z
        .object({
            symbol: FactionTraitSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });
}

/** @internal */
export namespace FactionJson$ {
    export type Inbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
        name: string;
        description: string;
        headquarters: string;
        traits: Array<FactionTraitJson$.Inbound>;
        isRecruiting: boolean;
    };

    export const inboundSchema: z.ZodType<FactionJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
            name: z.string(),
            description: z.string(),
            headquarters: z.string(),
            traits: z.array(z.lazy(() => FactionTraitJson$.inboundSchema)),
            isRecruiting: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                headquarters: v.headquarters,
                traits: v.traits,
                isRecruiting: v.isRecruiting,
            };
        });

    export type Outbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
        name: string;
        description: string;
        headquarters: string;
        traits: Array<FactionTraitJson$.Outbound>;
        isRecruiting: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, FactionJson> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
            name: z.string(),
            description: z.string(),
            headquarters: z.string(),
            traits: z.array(z.lazy(() => FactionTraitJson$.outboundSchema)),
            isRecruiting: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                headquarters: v.headquarters,
                traits: v.traits,
                isRecruiting: v.isRecruiting,
            };
        });
}

/** @internal */
export const ShipRoleJson$ = z.nativeEnum(ShipRoleJson);

/** @internal */
export namespace ShipRegistrationJson$ {
    export type Inbound = {
        name: string;
        factionSymbol: string;
        role: ShipRoleJson;
    };

    export const inboundSchema: z.ZodType<ShipRegistrationJson, z.ZodTypeDef, Inbound> = z
        .object({
            name: z.string(),
            factionSymbol: z.string(),
            role: ShipRoleJson$,
        })
        .transform((v) => {
            return {
                name: v.name,
                factionSymbol: v.factionSymbol,
                role: v.role,
            };
        });

    export type Outbound = {
        name: string;
        factionSymbol: string;
        role: ShipRoleJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipRegistrationJson> = z
        .object({
            name: z.string(),
            factionSymbol: z.string(),
            role: ShipRoleJson$,
        })
        .transform((v) => {
            return {
                name: v.name,
                factionSymbol: v.factionSymbol,
                role: v.role,
            };
        });
}

/** @internal */
export const WaypointTypeJsonWaypointTypeJson$ = z.nativeEnum(WaypointTypeJsonWaypointTypeJson);

/** @internal */
export namespace ShipNavRouteWaypointJson$ {
    export type Inbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
    };

    export const inboundSchema: z.ZodType<ShipNavRouteWaypointJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
            };
        });

    export type Outbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipNavRouteWaypointJson> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
            };
        });
}

/** @internal */
export namespace ShipNavRouteJson$ {
    export type Inbound = {
        destination: ShipNavRouteWaypointJson$.Inbound;
        origin: ShipNavRouteWaypointJson$.Inbound;
        departureTime: string;
        arrival: string;
    };

    export const inboundSchema: z.ZodType<ShipNavRouteJson, z.ZodTypeDef, Inbound> = z
        .object({
            destination: z.lazy(() => ShipNavRouteWaypointJson$.inboundSchema),
            origin: z.lazy(() => ShipNavRouteWaypointJson$.inboundSchema),
            departureTime: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v)),
            arrival: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v)),
        })
        .transform((v) => {
            return {
                destination: v.destination,
                origin: v.origin,
                departureTime: v.departureTime,
                arrival: v.arrival,
            };
        });

    export type Outbound = {
        destination: ShipNavRouteWaypointJson$.Outbound;
        origin: ShipNavRouteWaypointJson$.Outbound;
        departureTime: string;
        arrival: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipNavRouteJson> = z
        .object({
            destination: z.lazy(() => ShipNavRouteWaypointJson$.outboundSchema),
            origin: z.lazy(() => ShipNavRouteWaypointJson$.outboundSchema),
            departureTime: z.date().transform((v) => v.toISOString()),
            arrival: z.date().transform((v) => v.toISOString()),
        })
        .transform((v) => {
            return {
                destination: v.destination,
                origin: v.origin,
                departureTime: v.departureTime,
                arrival: v.arrival,
            };
        });
}

/** @internal */
export const ShipNavStatusJson$ = z.nativeEnum(ShipNavStatusJson);

/** @internal */
export const ShipNavFlightModeJsonShipNavFlightModeJson$ = z.nativeEnum(
    ShipNavFlightModeJsonShipNavFlightModeJson
);

/** @internal */
export namespace ShipNavJsonShipNavJson$ {
    export type Inbound = {
        systemSymbol: string;
        waypointSymbol: string;
        route: ShipNavRouteJson$.Inbound;
        status: ShipNavStatusJson;
        flightMode?: ShipNavFlightModeJsonShipNavFlightModeJson | undefined;
    };

    export const inboundSchema: z.ZodType<ShipNavJsonShipNavJson, z.ZodTypeDef, Inbound> = z
        .object({
            systemSymbol: z.string(),
            waypointSymbol: z.string(),
            route: z.lazy(() => ShipNavRouteJson$.inboundSchema),
            status: ShipNavStatusJson$,
            flightMode: ShipNavFlightModeJsonShipNavFlightModeJson$.default(
                ShipNavFlightModeJsonShipNavFlightModeJson.Cruise
            ),
        })
        .transform((v) => {
            return {
                systemSymbol: v.systemSymbol,
                waypointSymbol: v.waypointSymbol,
                route: v.route,
                status: v.status,
                flightMode: v.flightMode,
            };
        });

    export type Outbound = {
        systemSymbol: string;
        waypointSymbol: string;
        route: ShipNavRouteJson$.Outbound;
        status: ShipNavStatusJson;
        flightMode: ShipNavFlightModeJsonShipNavFlightModeJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipNavJsonShipNavJson> = z
        .object({
            systemSymbol: z.string(),
            waypointSymbol: z.string(),
            route: z.lazy(() => ShipNavRouteJson$.outboundSchema),
            status: ShipNavStatusJson$,
            flightMode: ShipNavFlightModeJsonShipNavFlightModeJson$.default(
                ShipNavFlightModeJsonShipNavFlightModeJson.Cruise
            ),
        })
        .transform((v) => {
            return {
                systemSymbol: v.systemSymbol,
                waypointSymbol: v.waypointSymbol,
                route: v.route,
                status: v.status,
                flightMode: v.flightMode,
            };
        });
}

/** @internal */
export const Rotation$ = z.nativeEnum(Rotation);

/** @internal */
export namespace ShipCrewJson$ {
    export type Inbound = {
        current: number;
        required: number;
        capacity: number;
        rotation?: Rotation | undefined;
        morale: number;
        wages: number;
    };

    export const inboundSchema: z.ZodType<ShipCrewJson, z.ZodTypeDef, Inbound> = z
        .object({
            current: z.number().int(),
            required: z.number().int(),
            capacity: z.number().int(),
            rotation: Rotation$.default(Rotation.Strict),
            morale: z.number().int(),
            wages: z.number().int(),
        })
        .transform((v) => {
            return {
                current: v.current,
                required: v.required,
                capacity: v.capacity,
                rotation: v.rotation,
                morale: v.morale,
                wages: v.wages,
            };
        });

    export type Outbound = {
        current: number;
        required: number;
        capacity: number;
        rotation: Rotation;
        morale: number;
        wages: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipCrewJson> = z
        .object({
            current: z.number().int(),
            required: z.number().int(),
            capacity: z.number().int(),
            rotation: Rotation$.default(Rotation.Strict),
            morale: z.number().int(),
            wages: z.number().int(),
        })
        .transform((v) => {
            return {
                current: v.current,
                required: v.required,
                capacity: v.capacity,
                rotation: v.rotation,
                morale: v.morale,
                wages: v.wages,
            };
        });
}

/** @internal */
export const Symbol$ = z.nativeEnum(Symbol);

/** @internal */
export namespace ShipFrameJson$ {
    export type Inbound = {
        symbol: Symbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        moduleSlots: number;
        mountingPoints: number;
        fuelCapacity: number;
        requirements: ShipRequirementsJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipFrameJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: Symbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            moduleSlots: z.number().int(),
            mountingPoints: z.number().int(),
            fuelCapacity: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                moduleSlots: v.moduleSlots,
                mountingPoints: v.mountingPoints,
                fuelCapacity: v.fuelCapacity,
                requirements: v.requirements,
            };
        });

    export type Outbound = {
        symbol: Symbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        moduleSlots: number;
        mountingPoints: number;
        fuelCapacity: number;
        requirements: ShipRequirementsJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipFrameJson> = z
        .object({
            symbol: Symbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            moduleSlots: z.number().int(),
            mountingPoints: z.number().int(),
            fuelCapacity: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                moduleSlots: v.moduleSlots,
                mountingPoints: v.mountingPoints,
                fuelCapacity: v.fuelCapacity,
                requirements: v.requirements,
            };
        });
}

/** @internal */
export const ShipReactorJsonSymbol$ = z.nativeEnum(ShipReactorJsonSymbol);

/** @internal */
export namespace ShipReactorJson$ {
    export type Inbound = {
        symbol: ShipReactorJsonSymbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        powerOutput: number;
        requirements: ShipRequirementsJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipReactorJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: ShipReactorJsonSymbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            powerOutput: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                powerOutput: v.powerOutput,
                requirements: v.requirements,
            };
        });

    export type Outbound = {
        symbol: ShipReactorJsonSymbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        powerOutput: number;
        requirements: ShipRequirementsJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipReactorJson> = z
        .object({
            symbol: ShipReactorJsonSymbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            powerOutput: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                powerOutput: v.powerOutput,
                requirements: v.requirements,
            };
        });
}

/** @internal */
export const ShipEngineJsonSymbol$ = z.nativeEnum(ShipEngineJsonSymbol);

/** @internal */
export namespace ShipEngineJson$ {
    export type Inbound = {
        symbol: ShipEngineJsonSymbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        speed: number;
        requirements: ShipRequirementsJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipEngineJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: ShipEngineJsonSymbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            speed: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                speed: v.speed,
                requirements: v.requirements,
            };
        });

    export type Outbound = {
        symbol: ShipEngineJsonSymbol;
        name: string;
        description: string;
        condition: number;
        integrity: number;
        speed: number;
        requirements: ShipRequirementsJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipEngineJson> = z
        .object({
            symbol: ShipEngineJsonSymbol$,
            name: z.string(),
            description: z.string(),
            condition: z.number(),
            integrity: z.number(),
            speed: z.number().int(),
            requirements: z.lazy(() => ShipRequirementsJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                condition: v.condition,
                integrity: v.integrity,
                speed: v.speed,
                requirements: v.requirements,
            };
        });
}

/** @internal */
export namespace CooldownJsonCooldownJson$ {
    export type Inbound = {
        shipSymbol: string;
        totalSeconds: number;
        remainingSeconds: number;
        expiration?: string | undefined;
    };

    export const inboundSchema: z.ZodType<CooldownJsonCooldownJson, z.ZodTypeDef, Inbound> = z
        .object({
            shipSymbol: z.string(),
            totalSeconds: z.number().int(),
            remainingSeconds: z.number().int(),
            expiration: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
        })
        .transform((v) => {
            return {
                shipSymbol: v.shipSymbol,
                totalSeconds: v.totalSeconds,
                remainingSeconds: v.remainingSeconds,
                ...(v.expiration === undefined ? null : { expiration: v.expiration }),
            };
        });

    export type Outbound = {
        shipSymbol: string;
        totalSeconds: number;
        remainingSeconds: number;
        expiration?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CooldownJsonCooldownJson> = z
        .object({
            shipSymbol: z.string(),
            totalSeconds: z.number().int(),
            remainingSeconds: z.number().int(),
            expiration: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
        })
        .transform((v) => {
            return {
                shipSymbol: v.shipSymbol,
                totalSeconds: v.totalSeconds,
                remainingSeconds: v.remainingSeconds,
                ...(v.expiration === undefined ? null : { expiration: v.expiration }),
            };
        });
}

/** @internal */
export const ShipModuleJsonSymbol$ = z.nativeEnum(ShipModuleJsonSymbol);

/** @internal */
export namespace ShipModuleJson$ {
    export type Inbound = {
        symbol: ShipModuleJsonSymbol;
        capacity?: number | undefined;
        range?: number | undefined;
        name: string;
        description: string;
        requirements: ShipRequirementsJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipModuleJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: ShipModuleJsonSymbol$,
            capacity: z.number().int().optional(),
            range: z.number().int().optional(),
            name: z.string(),
            description: z.string(),
            requirements: z.lazy(() => ShipRequirementsJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                ...(v.capacity === undefined ? null : { capacity: v.capacity }),
                ...(v.range === undefined ? null : { range: v.range }),
                name: v.name,
                description: v.description,
                requirements: v.requirements,
            };
        });

    export type Outbound = {
        symbol: ShipModuleJsonSymbol;
        capacity?: number | undefined;
        range?: number | undefined;
        name: string;
        description: string;
        requirements: ShipRequirementsJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipModuleJson> = z
        .object({
            symbol: ShipModuleJsonSymbol$,
            capacity: z.number().int().optional(),
            range: z.number().int().optional(),
            name: z.string(),
            description: z.string(),
            requirements: z.lazy(() => ShipRequirementsJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                ...(v.capacity === undefined ? null : { capacity: v.capacity }),
                ...(v.range === undefined ? null : { range: v.range }),
                name: v.name,
                description: v.description,
                requirements: v.requirements,
            };
        });
}

/** @internal */
export const ShipMountJsonSymbol$ = z.nativeEnum(ShipMountJsonSymbol);

/** @internal */
export const Deposits$ = z.nativeEnum(Deposits);

/** @internal */
export namespace ShipRequirementsJson$ {
    export type Inbound = {
        power?: number | undefined;
        crew?: number | undefined;
        slots?: number | undefined;
    };

    export const inboundSchema: z.ZodType<ShipRequirementsJson, z.ZodTypeDef, Inbound> = z
        .object({
            power: z.number().int().optional(),
            crew: z.number().int().optional(),
            slots: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                ...(v.power === undefined ? null : { power: v.power }),
                ...(v.crew === undefined ? null : { crew: v.crew }),
                ...(v.slots === undefined ? null : { slots: v.slots }),
            };
        });

    export type Outbound = {
        power?: number | undefined;
        crew?: number | undefined;
        slots?: number | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipRequirementsJson> = z
        .object({
            power: z.number().int().optional(),
            crew: z.number().int().optional(),
            slots: z.number().int().optional(),
        })
        .transform((v) => {
            return {
                ...(v.power === undefined ? null : { power: v.power }),
                ...(v.crew === undefined ? null : { crew: v.crew }),
                ...(v.slots === undefined ? null : { slots: v.slots }),
            };
        });
}

/** @internal */
export namespace ShipMountJsonShipMountJson$ {
    export type Inbound = {
        symbol: ShipMountJsonSymbol;
        name: string;
        description?: string | undefined;
        strength?: number | undefined;
        deposits?: Array<Deposits> | undefined;
        requirements: ShipRequirementsJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipMountJsonShipMountJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: ShipMountJsonSymbol$,
            name: z.string(),
            description: z.string().optional(),
            strength: z.number().int().optional(),
            deposits: z.array(Deposits$).optional(),
            requirements: z.lazy(() => ShipRequirementsJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                ...(v.description === undefined ? null : { description: v.description }),
                ...(v.strength === undefined ? null : { strength: v.strength }),
                ...(v.deposits === undefined ? null : { deposits: v.deposits }),
                requirements: v.requirements,
            };
        });

    export type Outbound = {
        symbol: ShipMountJsonSymbol;
        name: string;
        description?: string | undefined;
        strength?: number | undefined;
        deposits?: Array<Deposits> | undefined;
        requirements: ShipRequirementsJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipMountJsonShipMountJson> = z
        .object({
            symbol: ShipMountJsonSymbol$,
            name: z.string(),
            description: z.string().optional(),
            strength: z.number().int().optional(),
            deposits: z.array(Deposits$).optional(),
            requirements: z.lazy(() => ShipRequirementsJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                ...(v.description === undefined ? null : { description: v.description }),
                ...(v.strength === undefined ? null : { strength: v.strength }),
                ...(v.deposits === undefined ? null : { deposits: v.deposits }),
                requirements: v.requirements,
            };
        });
}

/** @internal */
export const TradeSymbolJsonTradeSymbolJson$ = z.nativeEnum(TradeSymbolJsonTradeSymbolJson);

/** @internal */
export namespace ShipCargoItemJson$ {
    export type Inbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        name: string;
        description: string;
        units: number;
    };

    export const inboundSchema: z.ZodType<ShipCargoItemJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            name: z.string(),
            description: z.string(),
            units: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                units: v.units,
            };
        });

    export type Outbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        name: string;
        description: string;
        units: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipCargoItemJson> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            name: z.string(),
            description: z.string(),
            units: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
                units: v.units,
            };
        });
}

/** @internal */
export namespace ShipCargoJsonShipCargoJson$ {
    export type Inbound = {
        capacity: number;
        units: number;
        inventory: Array<ShipCargoItemJson$.Inbound>;
    };

    export const inboundSchema: z.ZodType<ShipCargoJsonShipCargoJson, z.ZodTypeDef, Inbound> = z
        .object({
            capacity: z.number().int(),
            units: z.number().int(),
            inventory: z.array(z.lazy(() => ShipCargoItemJson$.inboundSchema)),
        })
        .transform((v) => {
            return {
                capacity: v.capacity,
                units: v.units,
                inventory: v.inventory,
            };
        });

    export type Outbound = {
        capacity: number;
        units: number;
        inventory: Array<ShipCargoItemJson$.Outbound>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipCargoJsonShipCargoJson> = z
        .object({
            capacity: z.number().int(),
            units: z.number().int(),
            inventory: z.array(z.lazy(() => ShipCargoItemJson$.outboundSchema)),
        })
        .transform((v) => {
            return {
                capacity: v.capacity,
                units: v.units,
                inventory: v.inventory,
            };
        });
}

/** @internal */
export namespace Consumed$ {
    export type Inbound = {
        amount: number;
        timestamp: string;
    };

    export const inboundSchema: z.ZodType<Consumed, z.ZodTypeDef, Inbound> = z
        .object({
            amount: z.number().int(),
            timestamp: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v)),
        })
        .transform((v) => {
            return {
                amount: v.amount,
                timestamp: v.timestamp,
            };
        });

    export type Outbound = {
        amount: number;
        timestamp: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Consumed> = z
        .object({
            amount: z.number().int(),
            timestamp: z.date().transform((v) => v.toISOString()),
        })
        .transform((v) => {
            return {
                amount: v.amount,
                timestamp: v.timestamp,
            };
        });
}

/** @internal */
export namespace ShipFuelJsonShipFuelJson$ {
    export type Inbound = {
        current: number;
        capacity: number;
        consumed?: Consumed$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<ShipFuelJsonShipFuelJson, z.ZodTypeDef, Inbound> = z
        .object({
            current: z.number().int(),
            capacity: z.number().int(),
            consumed: z.lazy(() => Consumed$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                current: v.current,
                capacity: v.capacity,
                ...(v.consumed === undefined ? null : { consumed: v.consumed }),
            };
        });

    export type Outbound = {
        current: number;
        capacity: number;
        consumed?: Consumed$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipFuelJsonShipFuelJson> = z
        .object({
            current: z.number().int(),
            capacity: z.number().int(),
            consumed: z.lazy(() => Consumed$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                current: v.current,
                capacity: v.capacity,
                ...(v.consumed === undefined ? null : { consumed: v.consumed }),
            };
        });
}

/** @internal */
export namespace ShipJson$ {
    export type Inbound = {
        symbol: string;
        registration: ShipRegistrationJson$.Inbound;
        nav: ShipNavJsonShipNavJson$.Inbound;
        crew: ShipCrewJson$.Inbound;
        frame: ShipFrameJson$.Inbound;
        reactor: ShipReactorJson$.Inbound;
        engine: ShipEngineJson$.Inbound;
        cooldown: CooldownJsonCooldownJson$.Inbound;
        modules: Array<ShipModuleJson$.Inbound>;
        mounts: Array<ShipMountJsonShipMountJson$.Inbound>;
        cargo: ShipCargoJsonShipCargoJson$.Inbound;
        fuel: ShipFuelJsonShipFuelJson$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            registration: z.lazy(() => ShipRegistrationJson$.inboundSchema),
            nav: z.lazy(() => ShipNavJsonShipNavJson$.inboundSchema),
            crew: z.lazy(() => ShipCrewJson$.inboundSchema),
            frame: z.lazy(() => ShipFrameJson$.inboundSchema),
            reactor: z.lazy(() => ShipReactorJson$.inboundSchema),
            engine: z.lazy(() => ShipEngineJson$.inboundSchema),
            cooldown: z.lazy(() => CooldownJsonCooldownJson$.inboundSchema),
            modules: z.array(z.lazy(() => ShipModuleJson$.inboundSchema)),
            mounts: z.array(z.lazy(() => ShipMountJsonShipMountJson$.inboundSchema)),
            cargo: z.lazy(() => ShipCargoJsonShipCargoJson$.inboundSchema),
            fuel: z.lazy(() => ShipFuelJsonShipFuelJson$.inboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                registration: v.registration,
                nav: v.nav,
                crew: v.crew,
                frame: v.frame,
                reactor: v.reactor,
                engine: v.engine,
                cooldown: v.cooldown,
                modules: v.modules,
                mounts: v.mounts,
                cargo: v.cargo,
                fuel: v.fuel,
            };
        });

    export type Outbound = {
        symbol: string;
        registration: ShipRegistrationJson$.Outbound;
        nav: ShipNavJsonShipNavJson$.Outbound;
        crew: ShipCrewJson$.Outbound;
        frame: ShipFrameJson$.Outbound;
        reactor: ShipReactorJson$.Outbound;
        engine: ShipEngineJson$.Outbound;
        cooldown: CooldownJsonCooldownJson$.Outbound;
        modules: Array<ShipModuleJson$.Outbound>;
        mounts: Array<ShipMountJsonShipMountJson$.Outbound>;
        cargo: ShipCargoJsonShipCargoJson$.Outbound;
        fuel: ShipFuelJsonShipFuelJson$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipJson> = z
        .object({
            symbol: z.string(),
            registration: z.lazy(() => ShipRegistrationJson$.outboundSchema),
            nav: z.lazy(() => ShipNavJsonShipNavJson$.outboundSchema),
            crew: z.lazy(() => ShipCrewJson$.outboundSchema),
            frame: z.lazy(() => ShipFrameJson$.outboundSchema),
            reactor: z.lazy(() => ShipReactorJson$.outboundSchema),
            engine: z.lazy(() => ShipEngineJson$.outboundSchema),
            cooldown: z.lazy(() => CooldownJsonCooldownJson$.outboundSchema),
            modules: z.array(z.lazy(() => ShipModuleJson$.outboundSchema)),
            mounts: z.array(z.lazy(() => ShipMountJsonShipMountJson$.outboundSchema)),
            cargo: z.lazy(() => ShipCargoJsonShipCargoJson$.outboundSchema),
            fuel: z.lazy(() => ShipFuelJsonShipFuelJson$.outboundSchema),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                registration: v.registration,
                nav: v.nav,
                crew: v.crew,
                frame: v.frame,
                reactor: v.reactor,
                engine: v.engine,
                cooldown: v.cooldown,
                modules: v.modules,
                mounts: v.mounts,
                cargo: v.cargo,
                fuel: v.fuel,
            };
        });
}

/** @internal */
export const SystemTypeJson$ = z.nativeEnum(SystemTypeJson);

/** @internal */
export namespace WaypointOrbitalJson$ {
    export type Inbound = {
        symbol: string;
    };

    export const inboundSchema: z.ZodType<WaypointOrbitalJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });

    export type Outbound = {
        symbol: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, WaypointOrbitalJson> = z
        .object({
            symbol: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });
}

/** @internal */
export namespace SystemWaypointJson$ {
    export type Inbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Inbound>;
        orbits?: string | undefined;
    };

    export const inboundSchema: z.ZodType<SystemWaypointJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.inboundSchema)),
            orbits: z.string().optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.orbits === undefined ? null : { orbits: v.orbits }),
            };
        });

    export type Outbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Outbound>;
        orbits?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, SystemWaypointJson> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.outboundSchema)),
            orbits: z.string().optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.orbits === undefined ? null : { orbits: v.orbits }),
            };
        });
}

/** @internal */
export namespace SystemFactionJson$ {
    export type Inbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
    };

    export const inboundSchema: z.ZodType<SystemFactionJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });

    export type Outbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, SystemFactionJson> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });
}

/** @internal */
export namespace SystemJson$ {
    export type Inbound = {
        symbol: string;
        sectorSymbol: string;
        type: SystemTypeJson;
        x: number;
        y: number;
        waypoints: Array<SystemWaypointJson$.Inbound>;
        factions: Array<SystemFactionJson$.Inbound>;
    };

    export const inboundSchema: z.ZodType<SystemJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            sectorSymbol: z.string(),
            type: SystemTypeJson$,
            x: z.number().int(),
            y: z.number().int(),
            waypoints: z.array(z.lazy(() => SystemWaypointJson$.inboundSchema)),
            factions: z.array(z.lazy(() => SystemFactionJson$.inboundSchema)),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                sectorSymbol: v.sectorSymbol,
                type: v.type,
                x: v.x,
                y: v.y,
                waypoints: v.waypoints,
                factions: v.factions,
            };
        });

    export type Outbound = {
        symbol: string;
        sectorSymbol: string;
        type: SystemTypeJson;
        x: number;
        y: number;
        waypoints: Array<SystemWaypointJson$.Outbound>;
        factions: Array<SystemFactionJson$.Outbound>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, SystemJson> = z
        .object({
            symbol: z.string(),
            sectorSymbol: z.string(),
            type: SystemTypeJson$,
            x: z.number().int(),
            y: z.number().int(),
            waypoints: z.array(z.lazy(() => SystemWaypointJson$.outboundSchema)),
            factions: z.array(z.lazy(() => SystemFactionJson$.outboundSchema)),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                sectorSymbol: v.sectorSymbol,
                type: v.type,
                x: v.x,
                y: v.y,
                waypoints: v.waypoints,
                factions: v.factions,
            };
        });
}

/** @internal */
export namespace WaypointFactionJson$ {
    export type Inbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
    };

    export const inboundSchema: z.ZodType<WaypointFactionJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });

    export type Outbound = {
        symbol: FactionSymbolJsonFactionSymbolJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, WaypointFactionJson> = z
        .object({
            symbol: FactionSymbolJsonFactionSymbolJson$,
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
            };
        });
}

/** @internal */
export const WaypointTraitSymbolJsonWaypointTraitSymbolJson$ = z.nativeEnum(
    WaypointTraitSymbolJsonWaypointTraitSymbolJson
);

/** @internal */
export namespace WaypointTraitJson$ {
    export type Inbound = {
        symbol: WaypointTraitSymbolJsonWaypointTraitSymbolJson;
        name: string;
        description: string;
    };

    export const inboundSchema: z.ZodType<WaypointTraitJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: WaypointTraitSymbolJsonWaypointTraitSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });

    export type Outbound = {
        symbol: WaypointTraitSymbolJsonWaypointTraitSymbolJson;
        name: string;
        description: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, WaypointTraitJson> = z
        .object({
            symbol: WaypointTraitSymbolJsonWaypointTraitSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });
}

/** @internal */
export const WaypointModifierSymbolJson$ = z.nativeEnum(WaypointModifierSymbolJson);

/** @internal */
export namespace WaypointModifierJson$ {
    export type Inbound = {
        symbol: WaypointModifierSymbolJson;
        name: string;
        description: string;
    };

    export const inboundSchema: z.ZodType<WaypointModifierJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: WaypointModifierSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });

    export type Outbound = {
        symbol: WaypointModifierSymbolJson;
        name: string;
        description: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, WaypointModifierJson> = z
        .object({
            symbol: WaypointModifierSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });
}

/** @internal */
export namespace ChartJsonChartJson$ {
    export type Inbound = {
        waypointSymbol?: string | undefined;
        submittedBy?: string | undefined;
        submittedOn?: string | undefined;
    };

    export const inboundSchema: z.ZodType<ChartJsonChartJson, z.ZodTypeDef, Inbound> = z
        .object({
            waypointSymbol: z.string().optional(),
            submittedBy: z.string().optional(),
            submittedOn: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v))
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.waypointSymbol === undefined ? null : { waypointSymbol: v.waypointSymbol }),
                ...(v.submittedBy === undefined ? null : { submittedBy: v.submittedBy }),
                ...(v.submittedOn === undefined ? null : { submittedOn: v.submittedOn }),
            };
        });

    export type Outbound = {
        waypointSymbol?: string | undefined;
        submittedBy?: string | undefined;
        submittedOn?: string | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ChartJsonChartJson> = z
        .object({
            waypointSymbol: z.string().optional(),
            submittedBy: z.string().optional(),
            submittedOn: z
                .date()
                .transform((v) => v.toISOString())
                .optional(),
        })
        .transform((v) => {
            return {
                ...(v.waypointSymbol === undefined ? null : { waypointSymbol: v.waypointSymbol }),
                ...(v.submittedBy === undefined ? null : { submittedBy: v.submittedBy }),
                ...(v.submittedOn === undefined ? null : { submittedOn: v.submittedOn }),
            };
        });
}

/** @internal */
export namespace WaypointJson$ {
    export type Inbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Inbound>;
        orbits?: string | undefined;
        faction?: WaypointFactionJson$.Inbound | undefined;
        traits: Array<WaypointTraitJson$.Inbound>;
        modifiers?: Array<WaypointModifierJson$.Inbound> | undefined;
        chart?: ChartJsonChartJson$.Inbound | undefined;
        isUnderConstruction: boolean;
    };

    export const inboundSchema: z.ZodType<WaypointJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.inboundSchema)),
            orbits: z.string().optional(),
            faction: z.lazy(() => WaypointFactionJson$.inboundSchema).optional(),
            traits: z.array(z.lazy(() => WaypointTraitJson$.inboundSchema)),
            modifiers: z.array(z.lazy(() => WaypointModifierJson$.inboundSchema)).optional(),
            chart: z.lazy(() => ChartJsonChartJson$.inboundSchema).optional(),
            isUnderConstruction: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.orbits === undefined ? null : { orbits: v.orbits }),
                ...(v.faction === undefined ? null : { faction: v.faction }),
                traits: v.traits,
                ...(v.modifiers === undefined ? null : { modifiers: v.modifiers }),
                ...(v.chart === undefined ? null : { chart: v.chart }),
                isUnderConstruction: v.isUnderConstruction,
            };
        });

    export type Outbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Outbound>;
        orbits?: string | undefined;
        faction?: WaypointFactionJson$.Outbound | undefined;
        traits: Array<WaypointTraitJson$.Outbound>;
        modifiers?: Array<WaypointModifierJson$.Outbound> | undefined;
        chart?: ChartJsonChartJson$.Outbound | undefined;
        isUnderConstruction: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, WaypointJson> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.outboundSchema)),
            orbits: z.string().optional(),
            faction: z.lazy(() => WaypointFactionJson$.outboundSchema).optional(),
            traits: z.array(z.lazy(() => WaypointTraitJson$.outboundSchema)),
            modifiers: z.array(z.lazy(() => WaypointModifierJson$.outboundSchema)).optional(),
            chart: z.lazy(() => ChartJsonChartJson$.outboundSchema).optional(),
            isUnderConstruction: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.orbits === undefined ? null : { orbits: v.orbits }),
                ...(v.faction === undefined ? null : { faction: v.faction }),
                traits: v.traits,
                ...(v.modifiers === undefined ? null : { modifiers: v.modifiers }),
                ...(v.chart === undefined ? null : { chart: v.chart }),
                isUnderConstruction: v.isUnderConstruction,
            };
        });
}

/** @internal */
export namespace TradeGoodJson$ {
    export type Inbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        name: string;
        description: string;
    };

    export const inboundSchema: z.ZodType<TradeGoodJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });

    export type Outbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        name: string;
        description: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, TradeGoodJson> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            name: z.string(),
            description: z.string(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                name: v.name,
                description: v.description,
            };
        });
}

/** @internal */
export const MarketTransactionJsonType$ = z.nativeEnum(MarketTransactionJsonType);

/** @internal */
export namespace MarketTransactionJsonMarketTransactionJson$ {
    export type Inbound = {
        waypointSymbol: string;
        shipSymbol: string;
        tradeSymbol: string;
        type: MarketTransactionJsonType;
        units: number;
        pricePerUnit: number;
        totalPrice: number;
        timestamp: string;
    };

    export const inboundSchema: z.ZodType<
        MarketTransactionJsonMarketTransactionJson,
        z.ZodTypeDef,
        Inbound
    > = z
        .object({
            waypointSymbol: z.string(),
            shipSymbol: z.string(),
            tradeSymbol: z.string(),
            type: MarketTransactionJsonType$,
            units: z.number().int(),
            pricePerUnit: z.number().int(),
            totalPrice: z.number().int(),
            timestamp: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v)),
        })
        .transform((v) => {
            return {
                waypointSymbol: v.waypointSymbol,
                shipSymbol: v.shipSymbol,
                tradeSymbol: v.tradeSymbol,
                type: v.type,
                units: v.units,
                pricePerUnit: v.pricePerUnit,
                totalPrice: v.totalPrice,
                timestamp: v.timestamp,
            };
        });

    export type Outbound = {
        waypointSymbol: string;
        shipSymbol: string;
        tradeSymbol: string;
        type: MarketTransactionJsonType;
        units: number;
        pricePerUnit: number;
        totalPrice: number;
        timestamp: string;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        MarketTransactionJsonMarketTransactionJson
    > = z
        .object({
            waypointSymbol: z.string(),
            shipSymbol: z.string(),
            tradeSymbol: z.string(),
            type: MarketTransactionJsonType$,
            units: z.number().int(),
            pricePerUnit: z.number().int(),
            totalPrice: z.number().int(),
            timestamp: z.date().transform((v) => v.toISOString()),
        })
        .transform((v) => {
            return {
                waypointSymbol: v.waypointSymbol,
                shipSymbol: v.shipSymbol,
                tradeSymbol: v.tradeSymbol,
                type: v.type,
                units: v.units,
                pricePerUnit: v.pricePerUnit,
                totalPrice: v.totalPrice,
                timestamp: v.timestamp,
            };
        });
}

/** @internal */
export const MarketTradeGoodJsonType$ = z.nativeEnum(MarketTradeGoodJsonType);

/** @internal */
export const SupplyLevelJson$ = z.nativeEnum(SupplyLevelJson);

/** @internal */
export const ActivityLevelJson$ = z.nativeEnum(ActivityLevelJson);

/** @internal */
export namespace MarketTradeGoodJson$ {
    export type Inbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        type: MarketTradeGoodJsonType;
        tradeVolume: number;
        supply: SupplyLevelJson;
        activity?: ActivityLevelJson | undefined;
        purchasePrice: number;
        sellPrice: number;
    };

    export const inboundSchema: z.ZodType<MarketTradeGoodJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            type: MarketTradeGoodJsonType$,
            tradeVolume: z.number().int(),
            supply: SupplyLevelJson$,
            activity: ActivityLevelJson$.optional(),
            purchasePrice: z.number().int(),
            sellPrice: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                tradeVolume: v.tradeVolume,
                supply: v.supply,
                ...(v.activity === undefined ? null : { activity: v.activity }),
                purchasePrice: v.purchasePrice,
                sellPrice: v.sellPrice,
            };
        });

    export type Outbound = {
        symbol: TradeSymbolJsonTradeSymbolJson;
        type: MarketTradeGoodJsonType;
        tradeVolume: number;
        supply: SupplyLevelJson;
        activity?: ActivityLevelJson | undefined;
        purchasePrice: number;
        sellPrice: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, MarketTradeGoodJson> = z
        .object({
            symbol: TradeSymbolJsonTradeSymbolJson$,
            type: MarketTradeGoodJsonType$,
            tradeVolume: z.number().int(),
            supply: SupplyLevelJson$,
            activity: ActivityLevelJson$.optional(),
            purchasePrice: z.number().int(),
            sellPrice: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                tradeVolume: v.tradeVolume,
                supply: v.supply,
                ...(v.activity === undefined ? null : { activity: v.activity }),
                purchasePrice: v.purchasePrice,
                sellPrice: v.sellPrice,
            };
        });
}

/** @internal */
export namespace MarketJson$ {
    export type Inbound = {
        symbol: string;
        exports: Array<TradeGoodJson$.Inbound>;
        imports: Array<TradeGoodJson$.Inbound>;
        exchange: Array<TradeGoodJson$.Inbound>;
        transactions?: Array<MarketTransactionJsonMarketTransactionJson$.Inbound> | undefined;
        tradeGoods?: Array<MarketTradeGoodJson$.Inbound> | undefined;
    };

    export const inboundSchema: z.ZodType<MarketJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            exports: z.array(z.lazy(() => TradeGoodJson$.inboundSchema)),
            imports: z.array(z.lazy(() => TradeGoodJson$.inboundSchema)),
            exchange: z.array(z.lazy(() => TradeGoodJson$.inboundSchema)),
            transactions: z
                .array(z.lazy(() => MarketTransactionJsonMarketTransactionJson$.inboundSchema))
                .optional(),
            tradeGoods: z.array(z.lazy(() => MarketTradeGoodJson$.inboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                exports: v.exports,
                imports: v.imports,
                exchange: v.exchange,
                ...(v.transactions === undefined ? null : { transactions: v.transactions }),
                ...(v.tradeGoods === undefined ? null : { tradeGoods: v.tradeGoods }),
            };
        });

    export type Outbound = {
        symbol: string;
        exports: Array<TradeGoodJson$.Outbound>;
        imports: Array<TradeGoodJson$.Outbound>;
        exchange: Array<TradeGoodJson$.Outbound>;
        transactions?: Array<MarketTransactionJsonMarketTransactionJson$.Outbound> | undefined;
        tradeGoods?: Array<MarketTradeGoodJson$.Outbound> | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, MarketJson> = z
        .object({
            symbol: z.string(),
            exports: z.array(z.lazy(() => TradeGoodJson$.outboundSchema)),
            imports: z.array(z.lazy(() => TradeGoodJson$.outboundSchema)),
            exchange: z.array(z.lazy(() => TradeGoodJson$.outboundSchema)),
            transactions: z
                .array(z.lazy(() => MarketTransactionJsonMarketTransactionJson$.outboundSchema))
                .optional(),
            tradeGoods: z.array(z.lazy(() => MarketTradeGoodJson$.outboundSchema)).optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                exports: v.exports,
                imports: v.imports,
                exchange: v.exchange,
                ...(v.transactions === undefined ? null : { transactions: v.transactions }),
                ...(v.tradeGoods === undefined ? null : { tradeGoods: v.tradeGoods }),
            };
        });
}

/** @internal */
export namespace ShipTypes$ {
    export type Inbound = {
        type: ShipTypeJsonShipTypeJson;
    };

    export const inboundSchema: z.ZodType<ShipTypes, z.ZodTypeDef, Inbound> = z
        .object({
            type: ShipTypeJsonShipTypeJson$,
        })
        .transform((v) => {
            return {
                type: v.type,
            };
        });

    export type Outbound = {
        type: ShipTypeJsonShipTypeJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipTypes> = z
        .object({
            type: ShipTypeJsonShipTypeJson$,
        })
        .transform((v) => {
            return {
                type: v.type,
            };
        });
}

/** @internal */
export namespace ShipyardTransactionJsonShipyardTransactionJson$ {
    export type Inbound = {
        waypointSymbol: string;
        shipSymbol: string;
        shipType: string;
        price: number;
        agentSymbol: string;
        timestamp: string;
    };

    export const inboundSchema: z.ZodType<
        ShipyardTransactionJsonShipyardTransactionJson,
        z.ZodTypeDef,
        Inbound
    > = z
        .object({
            waypointSymbol: z.string(),
            shipSymbol: z.string(),
            shipType: z.string(),
            price: z.number().int(),
            agentSymbol: z.string(),
            timestamp: z
                .string()
                .datetime({ offset: true })
                .transform((v) => new Date(v)),
        })
        .transform((v) => {
            return {
                waypointSymbol: v.waypointSymbol,
                shipSymbol: v.shipSymbol,
                shipType: v.shipType,
                price: v.price,
                agentSymbol: v.agentSymbol,
                timestamp: v.timestamp,
            };
        });

    export type Outbound = {
        waypointSymbol: string;
        shipSymbol: string;
        shipType: string;
        price: number;
        agentSymbol: string;
        timestamp: string;
    };

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        ShipyardTransactionJsonShipyardTransactionJson
    > = z
        .object({
            waypointSymbol: z.string(),
            shipSymbol: z.string(),
            shipType: z.string(),
            price: z.number().int(),
            agentSymbol: z.string(),
            timestamp: z.date().transform((v) => v.toISOString()),
        })
        .transform((v) => {
            return {
                waypointSymbol: v.waypointSymbol,
                shipSymbol: v.shipSymbol,
                shipType: v.shipType,
                price: v.price,
                agentSymbol: v.agentSymbol,
                timestamp: v.timestamp,
            };
        });
}

/** @internal */
export const ShipTypeJsonShipTypeJson$ = z.nativeEnum(ShipTypeJsonShipTypeJson);

/** @internal */
export namespace Crew$ {
    export type Inbound = {
        required: number;
        capacity: number;
    };

    export const inboundSchema: z.ZodType<Crew, z.ZodTypeDef, Inbound> = z
        .object({
            required: z.number().int(),
            capacity: z.number().int(),
        })
        .transform((v) => {
            return {
                required: v.required,
                capacity: v.capacity,
            };
        });

    export type Outbound = {
        required: number;
        capacity: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Crew> = z
        .object({
            required: z.number().int(),
            capacity: z.number().int(),
        })
        .transform((v) => {
            return {
                required: v.required,
                capacity: v.capacity,
            };
        });
}

/** @internal */
export namespace ShipyardShipJson$ {
    export type Inbound = {
        type: ShipTypeJsonShipTypeJson;
        name: string;
        description: string;
        supply: SupplyLevelJson;
        activity?: ActivityLevelJson | undefined;
        purchasePrice: number;
        frame: ShipFrameJson$.Inbound;
        reactor: ShipReactorJson$.Inbound;
        engine: ShipEngineJson$.Inbound;
        modules: Array<ShipModuleJson$.Inbound>;
        mounts: Array<ShipMountJsonShipMountJson$.Inbound>;
        crew: Crew$.Inbound;
    };

    export const inboundSchema: z.ZodType<ShipyardShipJson, z.ZodTypeDef, Inbound> = z
        .object({
            type: ShipTypeJsonShipTypeJson$,
            name: z.string(),
            description: z.string(),
            supply: SupplyLevelJson$,
            activity: ActivityLevelJson$.optional(),
            purchasePrice: z.number().int(),
            frame: z.lazy(() => ShipFrameJson$.inboundSchema),
            reactor: z.lazy(() => ShipReactorJson$.inboundSchema),
            engine: z.lazy(() => ShipEngineJson$.inboundSchema),
            modules: z.array(z.lazy(() => ShipModuleJson$.inboundSchema)),
            mounts: z.array(z.lazy(() => ShipMountJsonShipMountJson$.inboundSchema)),
            crew: z.lazy(() => Crew$.inboundSchema),
        })
        .transform((v) => {
            return {
                type: v.type,
                name: v.name,
                description: v.description,
                supply: v.supply,
                ...(v.activity === undefined ? null : { activity: v.activity }),
                purchasePrice: v.purchasePrice,
                frame: v.frame,
                reactor: v.reactor,
                engine: v.engine,
                modules: v.modules,
                mounts: v.mounts,
                crew: v.crew,
            };
        });

    export type Outbound = {
        type: ShipTypeJsonShipTypeJson;
        name: string;
        description: string;
        supply: SupplyLevelJson;
        activity?: ActivityLevelJson | undefined;
        purchasePrice: number;
        frame: ShipFrameJson$.Outbound;
        reactor: ShipReactorJson$.Outbound;
        engine: ShipEngineJson$.Outbound;
        modules: Array<ShipModuleJson$.Outbound>;
        mounts: Array<ShipMountJsonShipMountJson$.Outbound>;
        crew: Crew$.Outbound;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipyardShipJson> = z
        .object({
            type: ShipTypeJsonShipTypeJson$,
            name: z.string(),
            description: z.string(),
            supply: SupplyLevelJson$,
            activity: ActivityLevelJson$.optional(),
            purchasePrice: z.number().int(),
            frame: z.lazy(() => ShipFrameJson$.outboundSchema),
            reactor: z.lazy(() => ShipReactorJson$.outboundSchema),
            engine: z.lazy(() => ShipEngineJson$.outboundSchema),
            modules: z.array(z.lazy(() => ShipModuleJson$.outboundSchema)),
            mounts: z.array(z.lazy(() => ShipMountJsonShipMountJson$.outboundSchema)),
            crew: z.lazy(() => Crew$.outboundSchema),
        })
        .transform((v) => {
            return {
                type: v.type,
                name: v.name,
                description: v.description,
                supply: v.supply,
                ...(v.activity === undefined ? null : { activity: v.activity }),
                purchasePrice: v.purchasePrice,
                frame: v.frame,
                reactor: v.reactor,
                engine: v.engine,
                modules: v.modules,
                mounts: v.mounts,
                crew: v.crew,
            };
        });
}

/** @internal */
export namespace ShipyardJson$ {
    export type Inbound = {
        symbol: string;
        shipTypes: Array<ShipTypes$.Inbound>;
        transactions?: Array<ShipyardTransactionJsonShipyardTransactionJson$.Inbound> | undefined;
        ships?: Array<ShipyardShipJson$.Inbound> | undefined;
        modificationsFee: number;
    };

    export const inboundSchema: z.ZodType<ShipyardJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            shipTypes: z.array(z.lazy(() => ShipTypes$.inboundSchema)),
            transactions: z
                .array(z.lazy(() => ShipyardTransactionJsonShipyardTransactionJson$.inboundSchema))
                .optional(),
            ships: z.array(z.lazy(() => ShipyardShipJson$.inboundSchema)).optional(),
            modificationsFee: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                shipTypes: v.shipTypes,
                ...(v.transactions === undefined ? null : { transactions: v.transactions }),
                ...(v.ships === undefined ? null : { ships: v.ships }),
                modificationsFee: v.modificationsFee,
            };
        });

    export type Outbound = {
        symbol: string;
        shipTypes: Array<ShipTypes$.Outbound>;
        transactions?: Array<ShipyardTransactionJsonShipyardTransactionJson$.Outbound> | undefined;
        ships?: Array<ShipyardShipJson$.Outbound> | undefined;
        modificationsFee: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipyardJson> = z
        .object({
            symbol: z.string(),
            shipTypes: z.array(z.lazy(() => ShipTypes$.outboundSchema)),
            transactions: z
                .array(z.lazy(() => ShipyardTransactionJsonShipyardTransactionJson$.outboundSchema))
                .optional(),
            ships: z.array(z.lazy(() => ShipyardShipJson$.outboundSchema)).optional(),
            modificationsFee: z.number().int(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                shipTypes: v.shipTypes,
                ...(v.transactions === undefined ? null : { transactions: v.transactions }),
                ...(v.ships === undefined ? null : { ships: v.ships }),
                modificationsFee: v.modificationsFee,
            };
        });
}

/** @internal */
export namespace ConstructionMaterialJson$ {
    export type Inbound = {
        tradeSymbol: TradeSymbolJsonTradeSymbolJson;
        required: number;
        fulfilled: number;
    };

    export const inboundSchema: z.ZodType<ConstructionMaterialJson, z.ZodTypeDef, Inbound> = z
        .object({
            tradeSymbol: TradeSymbolJsonTradeSymbolJson$,
            required: z.number().int(),
            fulfilled: z.number().int(),
        })
        .transform((v) => {
            return {
                tradeSymbol: v.tradeSymbol,
                required: v.required,
                fulfilled: v.fulfilled,
            };
        });

    export type Outbound = {
        tradeSymbol: TradeSymbolJsonTradeSymbolJson;
        required: number;
        fulfilled: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ConstructionMaterialJson> = z
        .object({
            tradeSymbol: TradeSymbolJsonTradeSymbolJson$,
            required: z.number().int(),
            fulfilled: z.number().int(),
        })
        .transform((v) => {
            return {
                tradeSymbol: v.tradeSymbol,
                required: v.required,
                fulfilled: v.fulfilled,
            };
        });
}

/** @internal */
export namespace ConstructionJson$ {
    export type Inbound = {
        symbol: string;
        materials: Array<ConstructionMaterialJson$.Inbound>;
        isComplete: boolean;
    };

    export const inboundSchema: z.ZodType<ConstructionJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            materials: z.array(z.lazy(() => ConstructionMaterialJson$.inboundSchema)),
            isComplete: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                materials: v.materials,
                isComplete: v.isComplete,
            };
        });

    export type Outbound = {
        symbol: string;
        materials: Array<ConstructionMaterialJson$.Outbound>;
        isComplete: boolean;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ConstructionJson> = z
        .object({
            symbol: z.string(),
            materials: z.array(z.lazy(() => ConstructionMaterialJson$.outboundSchema)),
            isComplete: z.boolean(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                materials: v.materials,
                isComplete: v.isComplete,
            };
        });
}

/** @internal */
export namespace ShipCargoJson$ {
    export type Inbound = {
        capacity: number;
        units: number;
        inventory: Array<ShipCargoItemJson$.Inbound>;
    };

    export const inboundSchema: z.ZodType<ShipCargoJson, z.ZodTypeDef, Inbound> = z
        .object({
            capacity: z.number().int(),
            units: z.number().int(),
            inventory: z.array(z.lazy(() => ShipCargoItemJson$.inboundSchema)),
        })
        .transform((v) => {
            return {
                capacity: v.capacity,
                units: v.units,
                inventory: v.inventory,
            };
        });

    export type Outbound = {
        capacity: number;
        units: number;
        inventory: Array<ShipCargoItemJson$.Outbound>;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipCargoJson> = z
        .object({
            capacity: z.number().int(),
            units: z.number().int(),
            inventory: z.array(z.lazy(() => ShipCargoItemJson$.outboundSchema)),
        })
        .transform((v) => {
            return {
                capacity: v.capacity,
                units: v.units,
                inventory: v.inventory,
            };
        });
}

/** @internal */
export namespace ShipNavJson$ {
    export type Inbound = {
        systemSymbol: string;
        waypointSymbol: string;
        route: ShipNavRouteJson$.Inbound;
        status: ShipNavStatusJson;
        flightMode?: ShipNavFlightModeJsonShipNavFlightModeJson | undefined;
    };

    export const inboundSchema: z.ZodType<ShipNavJson, z.ZodTypeDef, Inbound> = z
        .object({
            systemSymbol: z.string(),
            waypointSymbol: z.string(),
            route: z.lazy(() => ShipNavRouteJson$.inboundSchema),
            status: ShipNavStatusJson$,
            flightMode: ShipNavFlightModeJsonShipNavFlightModeJson$.default(
                ShipNavFlightModeJsonShipNavFlightModeJson.Cruise
            ),
        })
        .transform((v) => {
            return {
                systemSymbol: v.systemSymbol,
                waypointSymbol: v.waypointSymbol,
                route: v.route,
                status: v.status,
                flightMode: v.flightMode,
            };
        });

    export type Outbound = {
        systemSymbol: string;
        waypointSymbol: string;
        route: ShipNavRouteJson$.Outbound;
        status: ShipNavStatusJson;
        flightMode: ShipNavFlightModeJsonShipNavFlightModeJson;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ShipNavJson> = z
        .object({
            systemSymbol: z.string(),
            waypointSymbol: z.string(),
            route: z.lazy(() => ShipNavRouteJson$.outboundSchema),
            status: ShipNavStatusJson$,
            flightMode: ShipNavFlightModeJsonShipNavFlightModeJson$.default(
                ShipNavFlightModeJsonShipNavFlightModeJson.Cruise
            ),
        })
        .transform((v) => {
            return {
                systemSymbol: v.systemSymbol,
                waypointSymbol: v.waypointSymbol,
                route: v.route,
                status: v.status,
                flightMode: v.flightMode,
            };
        });
}

/** @internal */
export namespace ScannedWaypointJson$ {
    export type Inbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Inbound>;
        faction?: WaypointFactionJson$.Inbound | undefined;
        traits: Array<WaypointTraitJson$.Inbound>;
        chart?: ChartJsonChartJson$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<ScannedWaypointJson, z.ZodTypeDef, Inbound> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.inboundSchema)),
            faction: z.lazy(() => WaypointFactionJson$.inboundSchema).optional(),
            traits: z.array(z.lazy(() => WaypointTraitJson$.inboundSchema)),
            chart: z.lazy(() => ChartJsonChartJson$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.faction === undefined ? null : { faction: v.faction }),
                traits: v.traits,
                ...(v.chart === undefined ? null : { chart: v.chart }),
            };
        });

    export type Outbound = {
        symbol: string;
        type: WaypointTypeJsonWaypointTypeJson;
        systemSymbol: string;
        x: number;
        y: number;
        orbitals: Array<WaypointOrbitalJson$.Outbound>;
        faction?: WaypointFactionJson$.Outbound | undefined;
        traits: Array<WaypointTraitJson$.Outbound>;
        chart?: ChartJsonChartJson$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, ScannedWaypointJson> = z
        .object({
            symbol: z.string(),
            type: WaypointTypeJsonWaypointTypeJson$,
            systemSymbol: z.string(),
            x: z.number().int(),
            y: z.number().int(),
            orbitals: z.array(z.lazy(() => WaypointOrbitalJson$.outboundSchema)),
            faction: z.lazy(() => WaypointFactionJson$.outboundSchema).optional(),
            traits: z.array(z.lazy(() => WaypointTraitJson$.outboundSchema)),
            chart: z.lazy(() => ChartJsonChartJson$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                symbol: v.symbol,
                type: v.type,
                systemSymbol: v.systemSymbol,
                x: v.x,
                y: v.y,
                orbitals: v.orbitals,
                ...(v.faction === undefined ? null : { faction: v.faction }),
                traits: v.traits,
                ...(v.chart === undefined ? null : { chart: v.chart }),
            };
        });
}
